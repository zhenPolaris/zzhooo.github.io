<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>如果有一天 | Polaris✨</title>
  
  
  <link href="https://www.zhen0w0.cn/atom.xml" rel="self"/>
  
  <link href="https://www.zhen0w0.cn/"/>
  <updated>2025-05-10T17:40:00.000Z</updated>
  <id>https://www.zhen0w0.cn/</id>
  
  <author>
    <name>Polaris✨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Redis实践】zset排行榜</title>
    <link href="https://www.zhen0w0.cn/posts/a1ee2c95.html"/>
    <id>https://www.zhen0w0.cn/posts/a1ee2c95.html</id>
    <published>2025-05-10T17:40:00.000Z</published>
    <updated>2025-05-10T17:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><blockquote><p>排行榜的时效性不高，比如<strong>日榜，周榜</strong>这种，可以考虑通过<code>定时任务</code>统计、聚合数据并落库，需要查询的时候直接查询这个统计好的数据就好了。但有时候我们遇到的需求时效性会高一点，比如<strong>小时榜、分钟榜、甚至实时排行榜</strong>，这种情况下再使用定时任务统计的方式就不太合适</p></blockquote><h1 id="2-zset简介"><a href="#2-zset简介" class="headerlink" title="2.zset简介"></a>2.zset简介</h1><h2 id="2-1-操作指令"><a href="#2-1-操作指令" class="headerlink" title="2.1 操作指令"></a>2.1 操作指令</h2><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th><strong>详细指令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:left">zadd</td><td>zadd key score member</td><td>添加成员和分数，也可以替换成员分数</td></tr><tr><td style="text-align:left">zincrby</td><td>zincrby key score member</td><td>为某个成员累加分数，如果成员不存在则创建成员</td></tr><tr><td style="text-align:left">zrem</td><td>zrem key member</td><td>删除某个成员</td></tr><tr><td style="text-align:left">zscore</td><td>zscore key member</td><td>返回某个成员的分数</td></tr><tr><td style="text-align:left">zrange</td><td>zrange key 0 -1 withscores</td><td>按分值从小到大排</td></tr><tr><td style="text-align:left">zrevrange</td><td>zrevrange key 0 -1 withscores</td><td>按分值从大到小排</td></tr></tbody></table></div><blockquote><p>两个range方法，0 -1 是零和负一，中间用空格隔开，意思是获取所有的分数，如果是想获取指定数量的分数，例如top10，这里可以使用 0 9，最后一个withscores的意思的Redis会返回每个成员的分数。在没有这个选项的情况下，ZRANGE只会返回成员的名称，而不包括其对应的分数</p></blockquote><h2 id="2-2-使用示例"><a href="#2-2-使用示例" class="headerlink" title="2.2 使用示例"></a>2.2 使用示例</h2><ul><li>当前存在已下数据<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user1: 100</span><br><span class="line">user2: 200</span><br><span class="line">user3: 150</span><br></pre></td></tr></table></figure></li><li>通过指令实现排行榜<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zadd leaderboard 100 user1</span><br><span class="line">zadd leaderboard 200 user2</span><br><span class="line">zadd leaderboard 150 user3</span><br><span class="line"></span><br><span class="line">zrange leaderboard 0 -1 WITHSCORES</span><br><span class="line">zrevrange leaderboard 0 -1 WITHSCORES</span><br></pre></td></tr></table></figure><h1 id="3-实战"><a href="#3-实战" class="headerlink" title="3.实战"></a>3.实战</h1></li></ul><h2 id="3-1-RedisTemplate实现排行榜"><a href="#3-1-RedisTemplate实现排行榜" class="headerlink" title="3.1 RedisTemplate实现排行榜"></a>3.1 RedisTemplate实现排行榜</h2><ul><li>添加或替换用户分数</li><li>添加或更新用户分数</li><li>获取排行榜前N名</li><li>获取某个用户的排名</li><li>删除指定用户<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ZSetOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaderboardService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LEADERBOARD_KEY</span> <span class="operator">=</span> <span class="string">&quot;leaderboard&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加或替换用户分数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOrReplaceScore</span><span class="params">(String userId, <span class="type">double</span> score)</span> &#123;</span><br><span class="line">        ZSetOperations&lt;String, String&gt; zSetOps = redisTemplate.opsForZSet();</span><br><span class="line">        zSetOps.add(LEADERBOARD_KEY, userId, score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加或更新用户分数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOrUpdateScore</span><span class="params">(String userId, <span class="type">double</span> score)</span> &#123;</span><br><span class="line">        ZSetOperations&lt;String, String&gt; zSetOps = redisTemplate.opsForZSet();</span><br><span class="line">        zSetOps.incrementScore(LEADERBOARD_KEY, userId, score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取排行榜前N名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; getTopRanks(<span class="type">int</span> topN) &#123;</span><br><span class="line">        ZSetOperations&lt;String, String&gt; zSetOps = redisTemplate.opsForZSet();</span><br><span class="line">        <span class="keyword">return</span> zSetOps.reverseRangeWithScores(LEADERBOARD_KEY, <span class="number">0</span>, topN - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户排名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getUserRank</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        ZSetOperations&lt;String, String&gt; zSetOps = redisTemplate.opsForZSet();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">rank</span> <span class="operator">=</span> zSetOps.reverseRank(LEADERBOARD_KEY, userId);</span><br><span class="line">        <span class="comment">// 排名从1开始</span></span><br><span class="line">        <span class="keyword">return</span> rank != <span class="literal">null</span> ? rank + <span class="number">1</span> : <span class="literal">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        redisTemplate.opsForZSet().remove(LEADERBOARD_KEY, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-可能存在的问题及解决方案"><a href="#3-2-可能存在的问题及解决方案" class="headerlink" title="3.2.可能存在的问题及解决方案"></a>3.2.可能存在的问题及解决方案</h2><blockquote><p>一个活动如果参与的人数多，就可能出来成员一直不断膨胀的情况，但实际上我们对排行榜的需求往往只是需要前xx名的数据，例如前10名、前100名、前10000名等等。根据实际的需求，我们可以限制zset中的数量。假如现在保留一万名，就可以提供一个方法，清理排名一万以后的数据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制排行榜最大长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RANKING_SIZE</span> <span class="operator">=</span> <span class="number">10000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清理低活跃数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanUpInactiveUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    ZSetOperations&lt;String, String&gt; zSetOps = redisTemplate.opsForZSet();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">memberCount</span> <span class="operator">=</span> Optional.ofNullable(zSetOps.zCard(LEADERBOARD_KEY)).orElse(<span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">if</span> (memberCount &gt; MAX_RANKING_SIZE) &#123;</span><br><span class="line">        zSetOps.removeRange(LEADERBOARD_KEY, <span class="number">0</span>, -MAX_RANKING_SIZE - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个方法可以在插入新的成员时调用，但是由于会多次操作Redis，其实是不建议在保存排行榜分数的时候执行的，可以考虑通过定时任务来处理，</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledTasks</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LeaderboardService leaderboardService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每天凌晨2点清理</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 0 2 * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanInactiveUsersTask</span><span class="params">()</span> &#123;</span><br><span class="line">        leaderboardService.cleanUpInactiveUsers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-保留当前分数与最高分数"><a href="#3-2-2-保留当前分数与最高分数" class="headerlink" title="3.2.2.保留当前分数与最高分数"></a>3.2.2.保留当前分数与最高分数</h3><blockquote><p><code>zset</code>中针对同一个用户只能保存一个分数，如果要实现保存当前分数和最高分数，可考虑用两个<code>zset</code>来处理，处理方式也比较简单，按照：<strong>获取当前分数</strong>、<strong>比较分数</strong>、<strong>更新历史最高分数</strong>的顺序做就好了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">(String userId, <span class="type">double</span> newScore)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前分数</span></span><br><span class="line">    <span class="type">Double</span> <span class="variable">currentScore</span> <span class="operator">=</span> redisTemplate.opsForZSet().score(<span class="string">&quot;currentLeaderboard&quot;</span>, userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新当前分数</span></span><br><span class="line">    redisTemplate.opsForZSet().add(<span class="string">&quot;currentLeaderboard&quot;</span>, userId, newScore);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 更新历史最高分数</span></span><br><span class="line">    <span class="keyword">if</span> (currentScore == <span class="literal">null</span> || newScore &gt; currentScore) &#123;</span><br><span class="line">        redisTemplate.opsForZSet().add(<span class="string">&quot;highestLeaderboard&quot;</span>, userId, newScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-批量操作成员分数，减少并发"><a href="#3-2-3-批量操作成员分数，减少并发" class="headerlink" title="3.2.3.批量操作成员分数，减少并发"></a>3.2.3.批量操作成员分数，减少并发</h3><blockquote><p>在并发较高的情况下，如果想减少Redis插入请求，我们可以在内存中先保存一部分的请求，等达到某个阈值的时候，再做Redis的插入操作。这里阈值可以是积累了多少个成员做批量更新，也可以是积累到了一定的时间，例如积累了一分钟的数据。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberValue</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">ZSetOperations</span>.TypedTuple&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">private</span> Double score;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(Double score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(ZSetOperations.TypedTuple&lt;T&gt; o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; memberSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncBatchSetScore</span><span class="params">(String userId, <span class="type">double</span> score)</span> &#123;</span><br><span class="line">    MemberValue&lt;String&gt; memberValue = <span class="keyword">new</span> <span class="title class_">MemberValue</span>&lt;&gt;();</span><br><span class="line">    memberValue.setScore(score);</span><br><span class="line">    memberValue.setValue(userId);</span><br><span class="line">    <span class="keyword">synchronized</span> (LeaderboardService.class) &#123;</span><br><span class="line">        memberSet.add(memberValue);</span><br><span class="line">        <span class="keyword">if</span> (memberSet.size() &gt;= <span class="number">50</span>) &#123;</span><br><span class="line">            ZSetOperations&lt;String, String&gt; zSetOps = redisTemplate.opsForZSet();</span><br><span class="line">            zSetOps.add(LEADERBOARD_KEY, memberSet);</span><br><span class="line">            memberSet.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要修改阈值为时间，可以维护一个时间窗口，并修改判断条件即可</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Redis实战应用学习</summary>
    
    
    
    <category term="Redis" scheme="https://www.zhen0w0.cn/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.zhen0w0.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis-Plus @DS注解</title>
    <link href="https://www.zhen0w0.cn/posts/599943ca.html"/>
    <id>https://www.zhen0w0.cn/posts/599943ca.html</id>
    <published>2025-04-20T23:15:29.000Z</published>
    <updated>2025-04-20T23:15:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据源管理"><a href="#1-数据源管理" class="headerlink" title="1.数据源管理"></a>1.数据源管理</h2><ol><li>使用<code>com.baomidou.dynamic.datasource.AbstractRoutingDataSource</code>抽象类统一管理数据源，继承自spring-jdbc的<code>org.springframework.jdbc.datasource.AbstractDataSource</code></li><li>实现类<code>com.baomidou.dynamic.datasource.DynamicRoutingDataSource</code></li><li>初始化调用<code>public synchronized void addDataSource(String ds, DataSource dataSource)</code>加载数据源，数据源存进<code>dataSourceMap</code>中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 核心动态数据源组件  </span></span><br><span class="line"><span class="comment"> */</span><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicRoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;  </span><br><span class="line">     <span class="meta">@Setter</span>  </span><br><span class="line">     <span class="keyword">private</span> DynamicDataSourceProvider provider;</span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 添加数据源  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ds         数据源名称  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource 数据源  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addDataSource</span><span class="params">(String ds, DataSource dataSource)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (p6spy) &#123;  </span><br><span class="line">            dataSource = <span class="keyword">new</span> <span class="title class_">P6DataSource</span>(dataSource);  </span><br><span class="line">        &#125;  </span><br><span class="line">        dataSourceMap.put(ds, dataSource);  </span><br><span class="line">        <span class="keyword">if</span> (ds.contains(UNDERLINE)) &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> ds.split(UNDERLINE)[<span class="number">0</span>];  </span><br><span class="line">            <span class="keyword">if</span> (groupDataSources.containsKey(group)) &#123;  </span><br><span class="line">                groupDataSources.get(group).addDatasource(dataSource);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    <span class="type">DynamicGroupDataSource</span> <span class="variable">groupDatasource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicGroupDataSource</span>(group, strategy.newInstance());  </span><br><span class="line">                    groupDatasource.addDatasource(dataSource);  </span><br><span class="line">                    groupDataSources.put(group, groupDatasource);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                    log.error(<span class="string">&quot;添加数据源失败&quot;</span>, e);  </span><br><span class="line">                    dataSourceMap.remove(ds);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        log.info(<span class="string">&quot;动态数据源-加载 &#123;&#125; 成功&quot;</span>, ds);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        Map&lt;String, DataSource&gt; dataSources = provider.loadDataSources();  </span><br><span class="line">        log.info(<span class="string">&quot;初始共加载 &#123;&#125; 个数据源&quot;</span>, dataSources.size());  </span><br><span class="line">        <span class="comment">//添加并分组数据源  </span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, DataSource&gt; dsItem : dataSources.entrySet()) &#123;  </span><br><span class="line">            addDataSource(dsItem.getKey(), dsItem.getValue());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//检测默认数据源设置  </span></span><br><span class="line">        <span class="keyword">if</span> (groupDataSources.containsKey(primary)) &#123;  </span><br><span class="line">            log.info(<span class="string">&quot;当前的默认数据源是组数据源,组名为 &#123;&#125; ，其下有 &#123;&#125; 个数据源&quot;</span>, primary, groupDataSources.get(primary).size());  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataSourceMap.containsKey(primary)) &#123;  </span><br><span class="line">            log.info(<span class="string">&quot;当前的默认数据源是单数据源，数据源名为 &#123;&#125;&quot;</span>, primary);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;请检查primary默认数据库设置&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>上方只保留核心源码</p><ul><li><code>DynamicRoutingDataSource</code>实现了<code>InitializingBean</code>接口，会在配置文件加载成功后自动调用<code>afterPropertiesSet</code></li><li>调用<code>DynamicDataSourceProvider.loadDataSources()</code>加载配置文件</li></ul></blockquote><h2 id="2-数据操作-拦截-DS"><a href="#2-数据操作-拦截-DS" class="headerlink" title="2.数据操作-拦截@DS"></a>2.数据操作-拦截@DS</h2><blockquote><p>进行数据操作时，方法会被<code>com.baomidou.dynamic.datasource.aop.DynamicDataSourceAnnotationInterceptor</code>拦截</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 动态数据源AOP核心拦截器  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicDataSourceAnnotationInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * SPEL参数标识  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DYNAMIC_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;#&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Setter</span>  </span><br><span class="line">    <span class="keyword">private</span> DsProcessor dsProcessor;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">DynamicDataSourceClassResolver</span> <span class="variable">dynamicDataSourceClassResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicDataSourceClassResolver</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            DynamicDataSourceContextHolder.push(determineDatasource(invocation));  </span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            DynamicDataSourceContextHolder.poll();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">determineDatasource</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> invocation.getMethod();  </span><br><span class="line">        Class&lt;?&gt; declaringClass = dynamicDataSourceClassResolver.targetClass(invocation);  </span><br><span class="line">        <span class="type">DS</span> <span class="variable">ds</span> <span class="operator">=</span> method.isAnnotationPresent(DS.class) ? method.getAnnotation(DS.class)  </span><br><span class="line">                : AnnotationUtils.findAnnotation(declaringClass, DS.class);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> ds.value();  </span><br><span class="line">        <span class="keyword">return</span> (!key.isEmpty() &amp;&amp; key.startsWith(DYNAMIC_PREFIX)) ? dsProcessor.determineDatasource(invocation, key) : key;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>拦截器首先从被拦截的方法或者类（一般@DS注解用于Service，也可用于Mapper和Controller）上寻找<code>@DS</code>注解</li><li>获取到<code>@DS</code>注解的值后将其存入<code>com.baomidou.dynamic.datasource.toolkit.DynamicDataSourceContextHolder</code></li><li><code>DynamicDataSourceContextHolder</code>使用<code>ThreadLocal</code>存储当前线程的数据源名</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 核心基于ThreadLocal的切换数据源工具类   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DynamicDataSourceContextHolder</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 为什么要用链表存储(准确的是栈)  </span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;  </span></span><br><span class="line"><span class="comment">     * 为了支持嵌套切换，如ABC三个service都是不同的数据源  </span></span><br><span class="line"><span class="comment">     * 其中A的某个业务要调B的方法，B的方法需要调用C的方法。一级一级调用切换，形成了链。  </span></span><br><span class="line"><span class="comment">     * 传统的只设置当前线程的方式不能满足此业务需求，必须模拟栈，后进先出。  </span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Deque&lt;String&gt;&gt; LOOKUP_KEY_HOLDER = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">protected</span> Object <span class="title function_">initialValue</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DynamicDataSourceContextHolder</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 获得当前线程数据源  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数据源名称  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">peek</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> LOOKUP_KEY_HOLDER.get().peek();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 设置当前线程数据源  </span></span><br><span class="line"><span class="comment">     * &lt;p&gt;  </span></span><br><span class="line"><span class="comment">     * 如非必要不要手动调用，调用后确保最终清除  </span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ds 数据源名称  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(String ds)</span> &#123;  </span><br><span class="line">        LOOKUP_KEY_HOLDER.get().push(StringUtils.isEmpty(ds) ? <span class="string">&quot;&quot;</span> : ds);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 清空当前线程数据源  </span></span><br><span class="line"><span class="comment">     * &lt;p&gt;  </span></span><br><span class="line"><span class="comment">     * 如果当前线程是连续切换数据源  </span></span><br><span class="line"><span class="comment">     * 只会移除掉当前线程的数据源名称  </span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">()</span> &#123;  </span><br><span class="line">        Deque&lt;String&gt; deque = LOOKUP_KEY_HOLDER.get();  </span><br><span class="line">        deque.poll();  </span><br><span class="line">        <span class="keyword">if</span> (deque.isEmpty()) &#123;  </span><br><span class="line">            LOOKUP_KEY_HOLDER.remove();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 强制清空本地线程  </span></span><br><span class="line"><span class="comment">     * &lt;p&gt;  </span></span><br><span class="line"><span class="comment">     * 防止内存泄漏，如手动调用了push可调用此方法确保清除  </span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;  </span><br><span class="line">        LOOKUP_KEY_HOLDER.remove();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-数据操作-获取数据库连接"><a href="#3-数据操作-获取数据库连接" class="headerlink" title="3.数据操作-获取数据库连接"></a>3.数据操作-获取数据库连接</h2><blockquote><p>调用<code>org.springframework.jdbc.datasource.getConnection()</code>方法；<code>getConnection()</code>方法最终调用了<code>com.baomidou.dynamic.datasource.AbstractRoutingDataSource</code>的getConnection()方法；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;  </span><br><span class="line">    <span class="keyword">return</span> determineDataSource().getConnection();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>determineDataSource()</code>由子类<code>com.baomidou.dynamic.datasource.DynamicRoutingDataSource</code>实现，可以看到<code>DynamicRoutingDataSource</code>从<code>DynamicDataSourceContextHolder</code>获取数据源名称，这个在之前拦截器处理存进<code>ThreadLocal</code>中，如果有数据源名称则从<code>dataSourceMap</code>中获取，没有则获取默认的primary数据源。<br>==此时的数据源已经切换成了我们需要的数据源。==</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">determineDataSource</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> getDataSource(DynamicDataSourceContextHolder.peek());  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">getDataSource</span><span class="params">(String ds)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(ds)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> determinePrimaryDataSource();  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!groupDataSources.isEmpty() &amp;&amp; groupDataSources.containsKey(ds)) &#123;  </span><br><span class="line">        log.debug(<span class="string">&quot;从 &#123;&#125; 组数据源中返回数据源&quot;</span>, ds);  </span><br><span class="line">        <span class="keyword">return</span> groupDataSources.get(ds).determineDataSource();  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataSourceMap.containsKey(ds)) &#123;  </span><br><span class="line">        log.debug(<span class="string">&quot;从 &#123;&#125; 单数据源中返回数据源&quot;</span>, ds);  </span><br><span class="line">        <span class="keyword">return</span> dataSourceMap.get(ds);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (strict) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不能找到名称为&quot;</span> + ds + <span class="string">&quot;的数据源&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> determinePrimaryDataSource();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-清除当前数据源"><a href="#4-清除当前数据源" class="headerlink" title="4.清除当前数据源"></a>4.清除当前数据源</h2><blockquote><p>数据操作完成后，方法返回第二步中的拦截器，执行<code>DynamicDataSourceContextHolder.poll();</code>清除掉此次的数据源，避免影响后续数据操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        DynamicDataSourceContextHolder.push(determineDatasource(invocation));  </span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        DynamicDataSourceContextHolder.poll();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-相关依赖"><a href="#5-相关依赖" class="headerlink" title="5.相关依赖"></a>5.相关依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-示例yml配置"><a href="#6-示例yml配置" class="headerlink" title="6.示例yml配置"></a>6.示例yml配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> </span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">dynamic:</span></span><br><span class="line">      <span class="attr">primary:</span> <span class="string">dataSource1</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">dataSource1:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">          <span class="attr">driverClassName:</span> <span class="string">com.microsoft.sqlserver.jdbc.SQLServerDriver</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:sqlserver://localhost:1433;database=dataSource1</span></span><br><span class="line">          <span class="attr">username:</span> </span><br><span class="line">          <span class="attr">password:</span> </span><br><span class="line">        <span class="attr">dataSource2:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">          <span class="attr">driverClassName:</span> <span class="string">com.microsoft.sqlserver.jdbc.SQLServerDriver</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:sqlserver://localhost:1433;instanceName=sqlserver2017;DatabaseName=dataSource2</span></span><br><span class="line">          <span class="attr">username:</span> </span><br><span class="line">          <span class="attr">password:</span> </span><br></pre></td></tr></table></figure><h2 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7.注意事项"></a>7.注意事项</h2><blockquote><p>一个事务方法（方法被@Transactional修饰），如果出现对多个数据源进行操作的情况，子方法用<code>@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</code>修饰，参考Spring事务传播机制</p><p>上述配置含义为，将主方法事务暂时挂起，开启新事务去执行子方法</p></blockquote>]]></content>
    
    
    <summary type="html">mybatis-plus 使用@DS注解实现多数据源切换原理</summary>
    
    
    
    <category term="实用功能" scheme="https://www.zhen0w0.cn/categories/%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
    <category term="数据监控" scheme="https://www.zhen0w0.cn/tags/%E6%95%B0%E6%8D%AE%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>享元模式</title>
    <link href="https://www.zhen0w0.cn/posts/e19da94a.html"/>
    <id>https://www.zhen0w0.cn/posts/e19da94a.html</id>
    <published>2025-04-20T23:15:29.000Z</published>
    <updated>2025-04-20T23:15:35.000Z</updated>
    
    
    <summary type="html">设计模式之享元模式</summary>
    
    
    
    <category term="设计模式" scheme="https://www.zhen0w0.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://www.zhen0w0.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="享元模式" scheme="https://www.zhen0w0.cn/tags/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.zhen0w0.cn/posts/0.html"/>
    <id>https://www.zhen0w0.cn/posts/0.html</id>
    <published>2025-04-20T00:00:00.000Z</published>
    <updated>2025-07-14T13:01:41.379Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>疑问：为什么mybatis-plus可以根据dao中的参数是否包含page对象，给sql拼上对应的limit语句<br>==ps.这里研究的是最新版本(3.5.11)代码==</p></blockquote><h2 id="1-配置"><a href="#1-配置" class="headerlink" title="1.配置"></a>1.配置</h2><blockquote><p>当执行sql的时候mybatis-plus会对所有SQL语句进行拦截并做各种判断与附加操作(<code>这里只添加分页拦截器</code>),会进入到Mybatis-Plus全局拦截器.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  </span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();  </span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL)); <span class="comment">// 如果配置多个插件, 切记分页最后添加  </span></span><br><span class="line">    <span class="comment">// 如果有多数据源可以不配具体类型, 否则都建议配上具体的 DbType    return interceptor;  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="2-全局拦截器"><a href="#2-全局拦截器" class="headerlink" title="2.全局拦截器"></a>2.全局拦截器</h2><blockquote><p>主要关注下面这段代码<br>可以看出,当前sql执行时,被拦截器拦截,发现是查询语句,就会先执行winllDoQuery方法,其次做完在执行 beforeQuery<br>这两个方法的实现在具体的插件拦截器中，如下面的分页拦截器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (InnerInterceptor query : interceptors) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!query.willDoQuery(executor, ms, parameter, rowBounds, resultHandler, boundSql)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();  </span><br><span class="line">    &#125;  </span><br><span class="line">    query.beforeQuery(executor, ms, parameter, rowBounds, resultHandler, boundSql);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-分页拦截器"><a href="#3-分页拦截器" class="headerlink" title="3.分页拦截器"></a>3.分页拦截器</h2><h3 id="3-1-willDoQuery"><a href="#3-1-willDoQuery" class="headerlink" title="3.1 willDoQuery"></a>3.1 willDoQuery</h3><p>先count所有数据，将总数存入分页参数中</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">willDoQuery</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;  </span><br><span class="line">    IPage&lt;?&gt; page = ParameterUtils.findPage(parameter).orElse(<span class="literal">null</span>);  </span><br><span class="line">    <span class="keyword">if</span> (page == <span class="literal">null</span> || page.getSize() &lt; <span class="number">0</span> || !page.searchCount() || resultHandler != Executor.NO_RESULT_HANDLER) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    BoundSql countSql;  </span><br><span class="line">    <span class="type">MappedStatement</span> <span class="variable">countMs</span> <span class="operator">=</span> buildCountMappedStatement(ms, page.countId());  </span><br><span class="line">    <span class="keyword">if</span> (countMs != <span class="literal">null</span>) &#123;  </span><br><span class="line">        countSql = countMs.getBoundSql(parameter);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        countMs = buildAutoCountMappedStatement(ms);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">countSqlStr</span> <span class="operator">=</span> autoCountSql(page, boundSql.getSql());  </span><br><span class="line">        PluginUtils.<span class="type">MPBoundSql</span> <span class="variable">mpBoundSql</span> <span class="operator">=</span> PluginUtils.mpBoundSql(boundSql);  </span><br><span class="line">        countSql = <span class="keyword">new</span> <span class="title class_">BoundSql</span>(countMs.getConfiguration(), countSqlStr, mpBoundSql.parameterMappings(), parameter);  </span><br><span class="line">        PluginUtils.setAdditionalParameter(countSql, mpBoundSql.additionalParameters());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">CacheKey</span> <span class="variable">cacheKey</span> <span class="operator">=</span> executor.createCacheKey(countMs, parameter, rowBounds, countSql);  </span><br><span class="line">    List&lt;Object&gt; result = executor.query(countMs, parameter, rowBounds, resultHandler, cacheKey, countSql);  </span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(result)) &#123;  </span><br><span class="line">        <span class="comment">// 个别数据库 count 没数据不会返回 0        Object o = result.get(0);  </span></span><br><span class="line">        <span class="keyword">if</span> (o != <span class="literal">null</span>) &#123;  </span><br><span class="line">            total = Long.parseLong(o.toString());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    page.setTotal(total);  </span><br><span class="line">    <span class="keyword">return</span> continuePage(page);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-beforeQuery"><a href="#3-2-beforeQuery" class="headerlink" title="3.2 beforeQuery"></a>3.2 beforeQuery</h3><blockquote><p>判断数据操作是否有分页参数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IPage&lt;?&gt; page = ParameterUtils.findPage(parameter).orElse(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><blockquote><p>处理order拼接</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;OrderItem&gt; orders = page.orders();  </span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isNotEmpty(orders)) &#123;  </span><br><span class="line">    addOrdered = <span class="literal">true</span>;  </span><br><span class="line">    buildSql = <span class="built_in">this</span>.concatOrderBy(buildSql, orders);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>处理分页操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">handlerLimit(page, _limit);  </span><br><span class="line"><span class="type">IDialect</span> <span class="variable">dialect</span> <span class="operator">=</span> findIDialect(executor);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">final</span> <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();  </span><br><span class="line"><span class="type">DialectModel</span> <span class="variable">model</span> <span class="operator">=</span> dialect.buildPaginationSql(buildSql, page.offset(), page.getSize());  </span><br><span class="line">PluginUtils.<span class="type">MPBoundSql</span> <span class="variable">mpBoundSql</span> <span class="operator">=</span> PluginUtils.mpBoundSql(boundSql);  </span><br><span class="line">  </span><br><span class="line">List&lt;ParameterMapping&gt; mappings = mpBoundSql.parameterMappings();  </span><br><span class="line">Map&lt;String, Object&gt; additionalParameter = mpBoundSql.additionalParameters();  </span><br><span class="line">model.consumers(mappings, configuration, additionalParameter);  </span><br><span class="line">mpBoundSql.sql(model.getDialectSql());  </span><br><span class="line">mpBoundSql.parameterMappings(mappings);</span><br></pre></td></tr></table></figure><blockquote><p>未完待续。。。。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;疑问：为什么mybatis-plus可以根据dao中的参数是否包含page对象，给sql拼上对应的limit语句&lt;br&gt;==ps.这里研究的是最新版本(3.5.11)代码==&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-配置&quot;&gt;&lt;a h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Prometheus+Grafana监控</title>
    <link href="https://www.zhen0w0.cn/posts/9897cd72.html"/>
    <id>https://www.zhen0w0.cn/posts/9897cd72.html</id>
    <published>2025-03-24T23:22:54.000Z</published>
    <updated>2025-03-24T23:23:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><blockquote><p><a href="https://blog.csdn.net/qq_31725371/article/details/114697770">https://blog.csdn.net/qq_31725371/article/details/114697770</a></p></blockquote>]]></content>
    
    
    <summary type="html">Prometheus+Grafana实现监控相关资料汇总</summary>
    
    
    
    <category term="实用功能" scheme="https://www.zhen0w0.cn/categories/%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
    <category term="数据监控" scheme="https://www.zhen0w0.cn/tags/%E6%95%B0%E6%8D%AE%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>接口限流实现方式及算法</title>
    <link href="https://www.zhen0w0.cn/posts/40473701.html"/>
    <id>https://www.zhen0w0.cn/posts/40473701.html</id>
    <published>2025-03-14T00:02:31.000Z</published>
    <updated>2025-03-14T00:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="1-基于guava-限流实现（单机版）"><a href="#1-基于guava-限流实现（单机版）" class="headerlink" title="1.基于guava 限流实现（单机版）"></a>1.基于guava 限流实现（单机版）</h3><blockquote><p>guava 为谷歌开源的一个比较实用的组件，利用这个组件可以帮助开发人员完成常规的限流操作，接下来看具体的实现步骤</p></blockquote><h4 id="1-1-依赖引入"><a href="#1-1-依赖引入" class="headerlink" title="1.1 依赖引入"></a>1.1 依赖引入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>30.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-自定义注解"><a href="#1-2-自定义注解" class="headerlink" title="1.2 自定义注解"></a>1.2 自定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.limitRequest.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 自定义限流注解-基于gvava</span></span><br><span class="line"><span class="comment"> * User: zhen0w0</span></span><br><span class="line"><span class="comment"> * Date: 2025/3/14</span></span><br><span class="line"><span class="comment"> * Time: 00:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(value = ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GuavaLimitRateAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//限制类型</span></span><br><span class="line">    String <span class="title function_">limitType</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每秒五个请求</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">limitCount</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">5d</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-3-guava工具类"><a href="#1-3-guava工具类" class="headerlink" title="1.3 guava工具类"></a>1.3 guava工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.limitRequest.aspect;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 创建RateLimiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tcm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/10/12 17:55</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">RateLimiterHelper</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据mapkey，对不同注解类型限流</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, RateLimiter&gt; rateMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title function_">getRateLimiter</span><span class="params">(String limitType, <span class="type">double</span> limitCount )</span>&#123;</span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> rateMap.get(limitType);</span><br><span class="line">        <span class="keyword">if</span>(rateLimiter == <span class="literal">null</span>)&#123;</span><br><span class="line">            rateLimiter = RateLimiter.create(limitCount);</span><br><span class="line">            rateMap.put(limitType,rateLimiter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rateLimiter;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-AOP切面类"><a href="#1-4-AOP切面类" class="headerlink" title="1.4 AOP切面类"></a>1.4 AOP切面类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.limitRequest.aspect;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson2.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.util.JSONPObject;</span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"><span class="keyword">import</span> com.zhen.studytotal.limitRequest.annotation.GuavaLimitRateAnnotation;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 接口限流切面类</span></span><br><span class="line"><span class="comment"> * User: zhen0w0</span></span><br><span class="line"><span class="comment"> * Date: 2025/3/15</span></span><br><span class="line"><span class="comment"> * Time: 02:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuavaLimitRateAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(GuavaLimitRateAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(@com.zhen.studytotal.limitRequest.annotation.GuavaLimitRateAnnotation * *(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">limit</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        <span class="comment">//1.获取当前方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">currentMethod</span> <span class="operator">=</span> getCurrentMethod(joinPoint);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(currentMethod))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.获取注解参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">limitType</span> <span class="operator">=</span> currentMethod.getAnnotation(GuavaLimitRateAnnotation.class).limitType();</span><br><span class="line">        <span class="type">double</span> <span class="variable">limitCount</span> <span class="operator">=</span> currentMethod.getAnnotation(GuavaLimitRateAnnotation.class).limitCount();</span><br><span class="line">        <span class="comment">//3.使用guava令牌桶算法获取令牌，获取不到先等待</span></span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiterHelper.getRateLimiter(limitType, limitCount);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> rateLimiter.tryAcquire();</span><br><span class="line">        <span class="keyword">if</span> (b)&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;获取令牌成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();</span><br><span class="line">            <span class="comment">//这里使用的json第三方依赖为（fastjson2）</span></span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">            jsonObject.put(<span class="string">&quot;success&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            jsonObject.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;请求频繁，限流中···&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                output(response, jsonObject.toJSONString());</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                logger.error(<span class="string">&quot;限流异常:&#123;&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">(HttpServletResponse response, String jsonString)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream = response.getOutputStream();</span><br><span class="line">            outputStream.write(jsonString.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> outputStream != <span class="literal">null</span>;</span><br><span class="line">            outputStream.flush();</span><br><span class="line">            outputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Method <span class="title function_">getCurrentMethod</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        Method[] methods = joinPoint.getTarget().getClass().getMethods();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(joinPoint.getSignature().getName())) &#123;</span><br><span class="line">                target = method;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-5-测试"><a href="#1-5-测试" class="headerlink" title="1.5 测试"></a>1.5 测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.limitRequest.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhen.studytotal.limitRequest.annotation.GuavaLimitRateAnnotation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 限流测试</span></span><br><span class="line"><span class="comment"> * User: zhen0w0</span></span><br><span class="line"><span class="comment"> * Date: 2025/3/16</span></span><br><span class="line"><span class="comment"> * Time: 02:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test/guava&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGuavaController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/limit&quot;)</span></span><br><span class="line">    <span class="meta">@GuavaLimitRateAnnotation(limitType = &quot;测试guava限流&quot;, limitCount = 1)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;limit&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-6-效果"><a href="#1-6-效果" class="headerlink" title="1.6 效果"></a>1.6 效果</h4><blockquote><p>这里为了清楚看到效果，限流QPS设置为1，多刷新几次请求即可</p></blockquote><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/blog2025/20250316233852856.png" alt="image-20250316233852767"></p><h3 id="2-基于-redis-lua-限流实现（分布式版）"><a href="#2-基于-redis-lua-限流实现（分布式版）" class="headerlink" title="2. 基于 redis+lua 限流实现（分布式版）"></a>2. 基于 redis+lua 限流实现（分布式版）</h3><blockquote><p>redis是线程安全的，天然具有线程安全的特性，支持原子性操作，限流服务不仅需要承接超高QPS，还要保证限流逻辑的执行层面具备线程安全的特性，利用Redis这些特性做限流，既能保证线程安全，也能保证性能</p></blockquote><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/blog2025/20250317000152654.png" alt="image-20250317000152044"></p><p><code>结合流程图可以得出以下实现思路：</code></p><blockquote><p>1.编写 lua 脚本，指定入参的限流规则，比如对特定的接口限流时，可以根据某个或几个参数进行判定，调用该接口的请求，在一定的时间窗口内监控请求次数；<br>2.既然是限流，最好能够通用，可将限流规则应用到任何接口上，那么最合适的方式就是通过自定义注解形式切入；<br>3.提供一个配置类，被 spring 的容器管理，redisTemplate 中提供了 DefaultRedisScript这个 bean；<br>4.提供一个能动态解析接口参数的类，根据接口参数进行规则匹配后触发限流；</p></blockquote><h4 id="2-1-依赖"><a href="#2-1-依赖" class="headerlink" title="2.1 依赖"></a>2.1 依赖</h4><blockquote><p>YML文件记得添加redis相关配置</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-自定义注解"><a href="#2-2-自定义注解" class="headerlink" title="2.2 自定义注解"></a>2.2 自定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.limitRequest.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhen.studytotal.limitRequest.enums.LimitTypeEnum;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Description: redis限流注解</span></span><br><span class="line"><span class="comment">  * User: zhen0w0</span></span><br><span class="line"><span class="comment">  * Date: 2025/3/17</span></span><br><span class="line"><span class="comment">  * Time: 00:11</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(value = ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RedisLimitAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis-key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">key</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis-key前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">prefix</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限流时间内限流次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限流时间-单位秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">time</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限流类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LimitTypeEnum <span class="title function_">limitType</span><span class="params">()</span> <span class="keyword">default</span> LimitTypeEnum.INTERFACE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-限流类型枚举"><a href="#2-3-限流类型枚举" class="headerlink" title="2.3 限流类型枚举"></a>2.3 限流类型枚举</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.limitRequest.enums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: zhen0w0</span></span><br><span class="line"><span class="comment"> * Date: 2025/3/17</span></span><br><span class="line"><span class="comment"> * Time: 00:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">LimitTypeEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认限流策略，针对某一个接口进行限流</span></span><br><span class="line">    INTERFACE</span><br><span class="line">    ,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据IP地址进行限流</span></span><br><span class="line">    IP</span><br><span class="line">    ,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的Key</span></span><br><span class="line">    CUSTOMER</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-IP工具类"><a href="#2-4-IP工具类" class="headerlink" title="2.4 IP工具类"></a>2.4 IP工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.limitRequest.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpCookie;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: iputils</span></span><br><span class="line"><span class="comment"> * User: zhen0w0</span></span><br><span class="line"><span class="comment"> * Date: 2025/3/17</span></span><br><span class="line"><span class="comment"> * Time: 23:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IPUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getIpAddr</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;x-forwarded-for&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="literal">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="literal">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="literal">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="literal">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="literal">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本机访问</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;localhost&quot;</span>.equalsIgnoreCase(ip) || <span class="string">&quot;127.0.0.1&quot;</span>.equalsIgnoreCase(ip) || <span class="string">&quot;0:0:0:0:0:0:0:1&quot;</span>.equalsIgnoreCase(ip))&#123;</span><br><span class="line">            <span class="comment">// 根据网卡取本机配置的IP</span></span><br><span class="line">            InetAddress inet;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inet = InetAddress.getLocalHost();</span><br><span class="line">                ip = inet.getHostAddress();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照&#x27;,&#x27;分割</span></span><br><span class="line">        <span class="comment">//&quot;***.***.***.***&quot;.length() = 15</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != ip &amp;&amp; ip.length() &gt; <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ip.indexOf(<span class="string">&quot;,&quot;</span>) &gt; <span class="number">15</span>) &#123;</span><br><span class="line">                ip = ip.substring(<span class="number">0</span>, ip.indexOf(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-5-自定义-lua-脚本"><a href="#2-5-自定义-lua-脚本" class="headerlink" title="2.5 自定义 lua 脚本"></a>2.5 自定义 lua 脚本</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义变量：redis中key值、规定的时间段内访问次数、redis中过期时间、当前访问次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> count = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> current = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, key) <span class="keyword">or</span> <span class="string">&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current + <span class="number">1</span> &gt; limit <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">   <span class="comment">-- 没有超阈值，将当前访问数量+1，</span></span><br><span class="line">   current = redis.call(<span class="string">&quot;INCRBY&quot;</span>, key, <span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">tonumber</span>(current) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">   <span class="comment">-- 设置过期时间</span></span><br><span class="line">   redis.call(<span class="string">&quot;expire&quot;</span>, key, count)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">   <span class="keyword">return</span> current</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-6-Redis配置类"><a href="#2-6-Redis配置类" class="headerlink" title="2.6 Redis配置类"></a>2.6 Redis配置类</h4><blockquote><p>设置执行lua脚本，这里注意lua脚本返回类型，我这里原来采用number类型接收返回，报错</p><p><code>io.lettuce.core.output.ValueOutput does not support set(long)</code>，改用Long类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.limitRequest.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scripting.support.ResourceScriptSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: redis配置</span></span><br><span class="line"><span class="comment"> * User: zhen0w0</span></span><br><span class="line"><span class="comment"> * Date: 2025/3/17</span></span><br><span class="line"><span class="comment"> * Time: 00:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultRedisScript&lt;Long&gt; <span class="title function_">redisLuaScript</span><span class="params">()</span>&#123;</span><br><span class="line">        DefaultRedisScript&lt;Long&gt; numberDefaultRedisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        numberDefaultRedisScript.setScriptSource(<span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;lua\\limit.lua&quot;</span>)));</span><br><span class="line">        <span class="comment">//设置lua脚本返回值类型，需要和lua脚本的返回值类型一致</span></span><br><span class="line">        numberDefaultRedisScript.setResultType(Long.class);</span><br><span class="line">        <span class="keyword">return</span> numberDefaultRedisScript;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;redisTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate= <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="comment">//设置value的序列化方式为json</span></span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//设置key的序列化方式为string</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-Redis切面类"><a href="#2-7-Redis切面类" class="headerlink" title="2.7 Redis切面类"></a>2.7 Redis切面类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.limitRequest.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhen.studytotal.limitRequest.annotation.RedisLimitAnnotation;</span><br><span class="line"><span class="keyword">import</span> com.zhen.studytotal.limitRequest.enums.LimitTypeEnum;</span><br><span class="line"><span class="keyword">import</span> com.zhen.studytotal.limitRequest.utils.IPUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.Signature;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: reids限流切面</span></span><br><span class="line"><span class="comment"> * User: zhen0w0</span></span><br><span class="line"><span class="comment"> * Date: 2025/3/17</span></span><br><span class="line"><span class="comment"> * Time: 01:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLimitAspect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(RedisLimitAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DefaultRedisScript&lt;Long&gt; redisLuaScript;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.zhen.studytotal.limitRequest.annotation.RedisLimitAnnotation)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">redisLimit</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;redisLimit()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">interceptor</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> signature.getMethod();</span><br><span class="line">        <span class="type">RedisLimitAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getAnnotation(RedisLimitAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(annotation))&#123;</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getKeyByLimitType(annotation,signature);</span><br><span class="line">        <span class="comment">//调用lua脚本，获取返回结果，这里即为请求次数</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">number</span> <span class="operator">=</span> redisTemplate.execute(redisLuaScript, Collections.singletonList(key), annotation.count(), annotation.time());</span><br><span class="line">        logger.info(<span class="string">&quot;限流时时间内访问次数：&#123;&#125;&quot;</span>,number);</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="literal">null</span>  &amp;&amp; number.intValue() != <span class="number">0</span> &amp;&amp; number.intValue() &lt;= annotation.count())&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;限流时时间内访问次数：&#123;&#125;&quot;</span>,number);</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;访问次数超过限制,限流中···&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  三种redis-key</span></span><br><span class="line"><span class="comment">     *  1.自定义key：prefix + : + key</span></span><br><span class="line"><span class="comment">     *  2.接口限流：prefix + : + 接口全类名</span></span><br><span class="line"><span class="comment">     *  3.根据IP限流：prefix + : + IP地址 + - + 接口全类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signature</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getKeyByLimitType</span><span class="params">(RedisLimitAnnotation annotation, MethodSignature signature)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">LimitTypeEnum</span> <span class="variable">limitTypeEnum</span> <span class="operator">=</span> annotation.limitType();</span><br><span class="line">        <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> annotation.prefix();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(prefix))&#123;</span><br><span class="line">            key += prefix + <span class="string">&quot;:&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LimitTypeEnum.CUSTOMER == limitTypeEnum) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">tempKey</span> <span class="operator">=</span> annotation.key();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(tempKey)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;redis限流-&gt;自定义类型，key不能为空&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> key + tempKey;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> signature.getMethod();</span><br><span class="line">        Class&lt;?&gt; targetClass = method.getDeclaringClass();</span><br><span class="line">        <span class="type">String</span> <span class="variable">classFullName</span> <span class="operator">=</span> targetClass.getName() + <span class="string">&quot;-&quot;</span> + method.getName();</span><br><span class="line">        <span class="keyword">if</span> (LimitTypeEnum.INTERFACE == limitTypeEnum) &#123;</span><br><span class="line">            <span class="keyword">return</span> key + classFullName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//IP</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ipAddr</span> <span class="operator">=</span> IPUtils.getIpAddr(request);</span><br><span class="line">        <span class="keyword">return</span> key + ipAddr + <span class="string">&quot;-&quot;</span> + classFullName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-8-测试"><a href="#2-8-测试" class="headerlink" title="2.8 测试"></a>2.8 测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/redis&quot;)</span></span><br><span class="line"><span class="meta">@RedisLimitAnnotation(key = &quot;limitByRedis&quot;,time = 5,count = 5,limitType = LimitTypeEnum.IP)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRedis</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;REDIS&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/blog2025/20250318235256098.png" alt="image-20250318235255409"></p><h3 id="3-基于-sentinel-限流实现（分布式版）"><a href="#3-基于-sentinel-限流实现（分布式版）" class="headerlink" title="3.基于 sentinel 限流实现（分布式版）"></a>3.基于 sentinel 限流实现（分布式版）</h3><blockquote><p>sentinel 通常是需要结合 springcloud-alibaba 框架一起实用的，而且与框架集成之后，可以配合控制台一起使用达到更好的效果，实际上，sentinel 官方也提供了相对原生的 SDK 可供使用，接下来就以这种方式进行整合</p></blockquote><h4 id="3-1-依赖"><a href="#3-1-依赖" class="headerlink" title="3.1 依赖"></a>3.1 依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-自定义注解"><a href="#3-2-自定义注解" class="headerlink" title="3.2 自定义注解"></a>3.2 自定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.limitRequest.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: zhen0w0</span></span><br><span class="line"><span class="comment"> * Date: 2025/3/19</span></span><br><span class="line"><span class="comment"> * Time: 00:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(value = ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SentinelLimitRateAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//限制类型</span></span><br><span class="line">    String <span class="title function_">resourceName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每秒允许请求数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">limitCount</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-AOP切面"><a href="#3-3-AOP切面" class="headerlink" title="3.3 AOP切面"></a>3.3 AOP切面</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.limitRequest.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.Entry;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.SphU;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.Tracer;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.RuleConstant;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;</span><br><span class="line"><span class="keyword">import</span> com.zhen.studytotal.limitRequest.annotation.SentinelLimitRateAnnotation;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.checkerframework.checker.units.qual.A;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: zhen0w0</span></span><br><span class="line"><span class="comment"> * Date: 2025/3/19</span></span><br><span class="line"><span class="comment"> * Time: 00:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SentinelLimitRateAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;@annotation(com.zhen.studytotal.limitRequest.annotation.SentinelLimitRateAnnotation)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rateLimit</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;rateLimit()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取当前方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">currentMethod</span> <span class="operator">=</span> getCurrentMethod(joinPoint);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(currentMethod)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.从方法注解定义上获取限流的类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resourceName</span> <span class="operator">=</span> currentMethod.getAnnotation(SentinelLimitRateAnnotation.class).resourceName();</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(resourceName))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;资源名称为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">limitCount</span> <span class="operator">=</span> currentMethod.getAnnotation(SentinelLimitRateAnnotation.class).limitCount();</span><br><span class="line">        <span class="comment">// 3.初始化规则</span></span><br><span class="line">        initFlowRule(resourceName,limitCount);</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            entry = SphU.entry(resourceName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = joinPoint.proceed();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">            <span class="comment">// 资源访问阻止，被限流或被降级，在此处进行相应的处理操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;blocked&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;被限流了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Tracer.traceEntry(e, entry);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                entry.exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initFlowRule</span><span class="params">(String resourceName,<span class="type">int</span> limitCount)</span> &#123;</span><br><span class="line">        List&lt;FlowRule&gt; rules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">FlowRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowRule</span>();</span><br><span class="line">        <span class="comment">//设置受保护的资源</span></span><br><span class="line">        rule.setResource(resourceName);</span><br><span class="line">        <span class="comment">//设置流控规则 QPS</span></span><br><span class="line">        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">        <span class="comment">//设置受保护的资源阈值</span></span><br><span class="line">        rule.setCount(limitCount);</span><br><span class="line">        rules.add(rule);</span><br><span class="line">        <span class="comment">//加载配置好的规则</span></span><br><span class="line">        FlowRuleManager.loadRules(rules);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Method <span class="title function_">getCurrentMethod</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        Method[] methods = joinPoint.getTarget().getClass().getMethods();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(joinPoint.getSignature().getName())) &#123;</span><br><span class="line">                target = method;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4 测试"></a>3.4 测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sentinel&quot;)</span></span><br><span class="line"><span class="meta">@SentinelLimitRateAnnotation(resourceName = &quot;测试sentinel限流&quot;, limitCount = 1)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testSentinel</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Sentinel&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/blog2025/20250319003246668.png" alt="image-20250319003246529"></p><h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h3><h3 id="https-blog-csdn-net-truelove12358-article-details-127751003"><a href="#https-blog-csdn-net-truelove12358-article-details-127751003" class="headerlink" title="https://blog.csdn.net/truelove12358/article/details/127751003"></a><a href="https://blog.csdn.net/truelove12358/article/details/127751003">https://blog.csdn.net/truelove12358/article/details/127751003</a></h3>]]></content>
    
    
    <summary type="html">实践中几种接口限流实现方式，以及限流算法</summary>
    
    
    
    <category term="实用功能" scheme="https://www.zhen0w0.cn/categories/%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
    <category term="实用功能" scheme="https://www.zhen0w0.cn/tags/%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="https://www.zhen0w0.cn/posts/fe816c3c.html"/>
    <id>https://www.zhen0w0.cn/posts/fe816c3c.html</id>
    <published>2025-03-12T23:35:17.000Z</published>
    <updated>2025-03-12T23:35:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><blockquote><p>建造者模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。用户只需指定需要建造的类型就可以获得对象，建造过程及细节不需要了解。</p></blockquote><p><code>建造者（Builder）模式包含如下角色：</code></p><ul><li>抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。</li><li>具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</li><li>产品类（Product）：要创建的复杂对象。</li><li>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</li></ul><h3 id="1-常规写法"><a href="#1-常规写法" class="headerlink" title="1.常规写法"></a>1.常规写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.design.builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Currency;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: zhen0w0</span></span><br><span class="line"><span class="comment"> * Date: 2025/3/11</span></span><br><span class="line"><span class="comment"> * Time: 00:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">builder01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ComputerDirector</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComputerDirector</span>(<span class="keyword">new</span> <span class="title class_">MacComputerBuilder</span>());</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> director.buildComputer();</span><br><span class="line">        System.out.println(computer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String gpu;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String disk;</span><br><span class="line">    <span class="keyword">private</span> String power;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line">    <span class="keyword">private</span> String display;</span><br><span class="line">    <span class="keyword">private</span> String keyboard;</span><br><span class="line">    <span class="keyword">private</span> String mouse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象builder类，组装电脑</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ComputerBuilder</span> &#123;</span><br><span class="line">    <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildCpu</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildGpu</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildMemory</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildDisk</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildPower</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildMainboard</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildDisplay</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildKeyboard</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildMouse</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Computer <span class="title function_">build</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体 builder类 MAC桶电脑</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacComputerBuilder</span> <span class="keyword">implements</span> <span class="title class_">ComputerBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        computer.setCpu(<span class="string">&quot;i7&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildGpu</span><span class="params">()</span> &#123;</span><br><span class="line">        computer.setGpu(<span class="string">&quot;NVIDIA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        computer.setMemory(<span class="string">&quot;16G&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildDisk</span><span class="params">()</span> &#123;</span><br><span class="line">        computer.setDisk(<span class="string">&quot;1T&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPower</span><span class="params">()</span> &#123;</span><br><span class="line">        computer.setPower(<span class="string">&quot;220V&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMainboard</span><span class="params">()</span> &#123;</span><br><span class="line">        computer.setMainboard(<span class="string">&quot;华硕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        computer.setDisplay(<span class="string">&quot;27寸&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildKeyboard</span><span class="params">()</span> &#123;</span><br><span class="line">        computer.setKeyboard(<span class="string">&quot;苹果键盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        computer.setMouse(<span class="string">&quot;苹果鼠标&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指挥者类，负责组装电脑</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerDirector</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ComputerBuilder computerBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">buildComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        computerBuilder.buildCpu();</span><br><span class="line">        computerBuilder.buildGpu();</span><br><span class="line">        computerBuilder.buildMemory();</span><br><span class="line">        computerBuilder.buildDisk();</span><br><span class="line">        computerBuilder.buildPower();</span><br><span class="line">        computerBuilder.buildMainboard();</span><br><span class="line">        computerBuilder.buildDisplay();</span><br><span class="line">        computerBuilder.buildKeyboard();</span><br><span class="line">        computerBuilder.buildMouse();</span><br><span class="line">        <span class="keyword">return</span> computerBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-简化写法"><a href="#2-简化写法" class="headerlink" title="2.简化写法"></a>2.简化写法</h3><p><code>指挥者类和抽象类融合</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把指挥者类和抽象建造者合在一起的简化建造者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleComputerBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMotherBoard</span><span class="params">(String motherBoard)</span>&#123;</span><br><span class="line">        computer.setMotherboard(motherBoard);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildCpu</span><span class="params">(String cpu)</span>&#123;</span><br><span class="line">        computer.setCpu(cpu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMemory</span><span class="params">(String memory)</span>&#123;</span><br><span class="line">        computer.setMemory(memory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildDisk</span><span class="params">(String disk)</span>&#123;</span><br><span class="line">        computer.setDisk(disk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildGpu</span><span class="params">(String gpu)</span>&#123;</span><br><span class="line">        computer.setGpu(gpu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPower</span><span class="params">(String power)</span>&#123;</span><br><span class="line">        computer.setPower(power);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildHeatSink</span><span class="params">(String heatSink)</span>&#123;</span><br><span class="line">        computer.setHeatSink(heatSink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildChassis</span><span class="params">(String chassis)</span>&#123;</span><br><span class="line">        computer.setChassis(chassis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleComputerBuilder</span> <span class="variable">simpleComputerBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleComputerBuilder</span>();</span><br><span class="line">        simpleComputerBuilder.buildMotherBoard(<span class="string">&quot;Extreme主板&quot;</span>);</span><br><span class="line">        simpleComputerBuilder.buildCpu(<span class="string">&quot;Inter 12900K&quot;</span>);</span><br><span class="line">        simpleComputerBuilder.buildMemory(<span class="string">&quot;芝奇幻峰戟 16G*2&quot;</span>);</span><br><span class="line">        simpleComputerBuilder.buildDisk(<span class="string">&quot;三星980Pro 2T&quot;</span>);</span><br><span class="line">        simpleComputerBuilder.buildGpu(<span class="string">&quot;华硕3090Ti 水猛禽&quot;</span>);</span><br><span class="line">        simpleComputerBuilder.buildPower(<span class="string">&quot;雷神二代1200W&quot;</span>);</span><br><span class="line">        simpleComputerBuilder.buildHeatSink(<span class="string">&quot;龙神二代一体式水冷&quot;</span>);</span><br><span class="line">        simpleComputerBuilder.buildChassis(<span class="string">&quot;太阳神机箱&quot;</span>);</span><br><span class="line">        <span class="comment">// Computer(motherboard=Extreme主板, cpu=Inter 12900K, memory=芝奇幻峰戟 16G*2, disk=三星980Pro 2T, gpu=华硕3090Ti 水猛禽, power=雷神二代1200W, heatSink=龙神二代一体式水冷, chassis=太阳神机箱)</span></span><br><span class="line">        System.out.println(simpleComputerBuilder.build());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-链式写法"><a href="#3-链式写法" class="headerlink" title="3.链式写法"></a>3.链式写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleComputerBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SimpleComputerBuilder <span class="title function_">buildCpu</span><span class="params">(String cpu)</span> &#123;</span><br><span class="line">        computer.setCpu(cpu);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SimpleComputerBuilder <span class="title function_">buildGpu</span><span class="params">(String gpu)</span> &#123;</span><br><span class="line">        computer.setGpu(gpu);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SimpleComputerBuilder <span class="title function_">buildMemory</span><span class="params">(String memory)</span> &#123;</span><br><span class="line">        computer.setMemory(memory);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SimpleComputerBuilder <span class="title function_">buildDisk</span><span class="params">(String disk)</span> &#123;</span><br><span class="line">        computer.setDisk(disk);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SimpleComputerBuilder <span class="title function_">buildPower</span><span class="params">(String power)</span> &#123;</span><br><span class="line">        computer.setPower(power);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SimpleComputerBuilder <span class="title function_">buildMainboard</span><span class="params">(String mainboard)</span> &#123;</span><br><span class="line">        computer.setMainboard(mainboard);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SimpleComputerBuilder <span class="title function_">buildDisplay</span><span class="params">(String display)</span> &#123;</span><br><span class="line">        computer.setDisplay(display);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SimpleComputerBuilder <span class="title function_">buildKeyboard</span><span class="params">(String keyboard)</span> &#123;</span><br><span class="line">        computer.setKeyboard(keyboard);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> SimpleComputerBuilder <span class="title function_">buildMouse</span><span class="params">(String mouse)</span> &#123;</span><br><span class="line">        computer.setMouse(mouse);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><blockquote><p>适用场景：</p><ul><li>适用于创建对象需要很多步骤，但是步骤顺序不一定固定。</li><li>如果一个对象有非常复杂的内部结构（属性），把复杂对象的创建和使用进行分离。</li></ul><p>优点：</p><ul><li>封装性好，创建和使用分离。</li><li>扩展性好，建造类之间独立、一定程度上解耦。</li></ul><p>缺点：</p><ul><li>产生多余的Builder对象。</li><li>产品内部发生变化，建造者都要修改，成本较大。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">建造者模式简单了解</summary>
    
    
    
    <category term="设计模式" scheme="https://www.zhen0w0.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://www.zhen0w0.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="建造者模式" scheme="https://www.zhen0w0.cn/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="https://www.zhen0w0.cn/posts/6208627e.html"/>
    <id>https://www.zhen0w0.cn/posts/6208627e.html</id>
    <published>2025-03-10T00:47:20.000Z</published>
    <updated>2025-03-10T00:47:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><blockquote><p>职责链模式是将链中每一个节点看作是一个对象，每个节点处理的请求均不同，且内部自动维护一个下一节点对象。当一个请求从链式的首端发出时，会沿着链的路径依次传递给每一个节点对象，直至有对象处理这个请求为止</p><p>职责链模式主要包含以下角色：</p><ul><li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li></ul></blockquote><h3 id="1-1代码实现"><a href="#1-1代码实现" class="headerlink" title="1.1代码实现"></a>1.1代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.design.chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 设计模式-责任链模式</span></span><br><span class="line"><span class="comment"> * User: zhen0w0</span></span><br><span class="line"><span class="comment"> * Date: 2025/3/9</span></span><br><span class="line"><span class="comment"> * Time: 19:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChainTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhen&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">LoginService</span> <span class="variable">loginService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginService</span>();</span><br><span class="line">        loginService.login(user);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        loginService.login(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        user.setRole(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">        loginService.login(user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//handle抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handle</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Handle next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">(Handle next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doHandle</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户名密码空校验</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ValidateHandler</span> <span class="keyword">extends</span> <span class="title class_">Handle</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandle</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(user.getPassword()) || StringUtils.isBlank(user.getUsername()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名或密码为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名密码校验通过&quot;</span>);</span><br><span class="line">        next.doHandle(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录校验，校验用户名是否匹配密码</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">LoginHandler</span> <span class="keyword">extends</span> <span class="title class_">Handle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandle</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;zhen&quot;</span>.equals(user.getUsername()) || !<span class="string">&quot;123456&quot;</span>.equals(user.getPassword())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名或者密码不正确!请检查!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;登陆成功!角色为管理员!&quot;</span>);</span><br><span class="line">        next.doHandle(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 权限校验</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuthHandler</span> <span class="keyword">extends</span> <span class="title class_">Handle</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandle</span><span class="params">(User user)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;admin&quot;</span>.equals(user.getRole())) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;无权限操作!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;角色为管理员,可以进行下一步操作!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//登录流程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="type">Handle</span> <span class="variable">validateHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ValidateHandler</span>();</span><br><span class="line">        <span class="type">Handle</span> <span class="variable">loginHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginHandler</span>();</span><br><span class="line">        <span class="type">Handle</span> <span class="variable">authHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthHandler</span>();</span><br><span class="line"></span><br><span class="line">        validateHandler.next(loginHandler);</span><br><span class="line">        loginHandler.next(authHandler);</span><br><span class="line"></span><br><span class="line">        validateHandler.doHandle(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-结合建造者模式实现"><a href="#1-2-结合建造者模式实现" class="headerlink" title="1.2 结合建造者模式实现"></a>1.2 结合建造者模式实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handler抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler next;</span><br><span class="line">    <span class="comment">// 返回handler方便链式操作</span></span><br><span class="line">    <span class="keyword">public</span> Handler <span class="title function_">next</span><span class="params">(Handler next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 流程开始的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> Handler&lt;T&gt; head;</span><br><span class="line">        <span class="keyword">private</span> Handler&lt;T&gt; tail;</span><br><span class="line">        <span class="keyword">public</span> Builder&lt;T&gt; <span class="title function_">addHandler</span><span class="params">(Handler&lt;T&gt; handler)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.head = <span class="built_in">this</span>.tail = handler;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.tail.next(handler);</span><br><span class="line">            <span class="built_in">this</span>.tail = handler;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Handler&lt;T&gt; <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        Handler.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>.Builder();</span><br><span class="line">        builder.addHandler(<span class="keyword">new</span> <span class="title class_">ValidateHandler</span>())</span><br><span class="line">            .addHandler(<span class="keyword">new</span> <span class="title class_">LoginHandler</span>())</span><br><span class="line">            .addHandler(<span class="keyword">new</span> <span class="title class_">AuthHandler</span>());</span><br><span class="line">        builder.build().doHandler(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h3><blockquote><p>适用场景：</p><ul><li>多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定。</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li><li>可动态指定一组对象处理请求。</li></ul><p>优点：</p><ul><li>将请求与处理解耦。</li><li>请求处理者（节点对象）只需关注自己感兴趣的请求进行处理即可，对于不感兴趣的请求，直接转发给下一级节点对象。</li><li>具备链式传递处理请求功能，请求发送者无需知晓链路结构，只需等待请求处理结果。</li><li>链路结构灵活，可以通过改变链路结构动态地新增或删减责任。</li><li>易于扩展新的请求处理类（节点），符合开闭原则。</li></ul><p>缺点：</p><ul><li>责任链太长或者处理时间过长，会影响整体性能。</li><li>如果节点对象存在循环引用时，会造成死循环，导致系统崩溃。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">责任链模式简单记录</summary>
    
    
    
    <category term="设计模式" scheme="https://www.zhen0w0.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://www.zhen0w0.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法模式</title>
    <link href="https://www.zhen0w0.cn/posts/48598499.html"/>
    <id>https://www.zhen0w0.cn/posts/48598499.html</id>
    <published>2025-03-07T00:42:17.000Z</published>
    <updated>2025-03-07T00:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1.简单工厂模式"></a>1.简单工厂模式</h2><h3 id="1-1基础版"><a href="#1-1基础版" class="headerlink" title="1.1基础版"></a>1.1基础版</h3><blockquote><p>简单工厂模式不是23种设计模式之一，他可以理解为工厂模式的一种简单的特殊实现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产品基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 产品具体类，实现产品基类接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cappuccino</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他实现类、、、、</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">create</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Americano</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;mocha&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Mocha</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;cappuccino&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cappuccino</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2升级版"><a href="#1-2升级版" class="headerlink" title="1.2升级版"></a>1.2升级版</h3><blockquote><p>升级版就很好的解决基础版的问题，在创建的时候在传参的时候不仅会有代码提示，保证不会写错，同时在新增产品的时候只需要新增产品类即可，也不需要再在工厂类的方法里面新增代码了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反射创建对象</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">creat</span><span class="params">(Class&lt;? extends Coffee&gt; clazz)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-3总结"><a href="#1-3总结" class="headerlink" title="1.3总结"></a>1.3总结</h3><blockquote><ul><li>工厂类负责创建的对象较少。</li><li>客户端只需要传入工厂类的参数，对于如何创建的对象的逻辑不需要关心。</li><li>只需要传入一个正确的参数，就可以获取你所需要的对象，无须知道创建的细节。</li><li>工厂类的职责相对过重，增加新的产品类型的时需要修改工厂类的判断逻辑，违背了开闭原则。</li><li>不易于扩展过于复杂的产品结构。</li></ul></blockquote><h2 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2.工厂方法模式"></a>2.工厂方法模式</h2><blockquote><p>工厂方法模式是指定义一个创建对象的接口，让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。工厂方法模式主要有以下角色：</p><p>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。<br>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。<br>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。<br>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它和具体工厂之间一一对应。</p></blockquote><h3 id="2-1-代码实现"><a href="#2-1-代码实现" class="headerlink" title="2.1 代码实现"></a>2.1 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    Coffee <span class="title function_">create</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CappuccinoFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cappuccino</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cappuccino</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-总结"><a href="#2-2-总结" class="headerlink" title="2.2 总结"></a>2.2 总结</h3><blockquote><p>适用场景</p><ul><li>创建对象需要大量的重复代码。</li><li>客户端（应用层）不依赖于产品类实例如何被创建和实现等细节。</li><li>一个类通过其子类来指定创建哪个对象。</li></ul><p>优点</p><ul><li>用户只需要关系所需产品对应的工厂，无须关心创建细节。</li><li>加入新产品符合开闭原则，提高了系统的可扩展性。 </li></ul><p>缺点</p><ul><li>类的数量容易过多，增加了代码结构的复杂度。</li><li>增加了系统的抽象性和理解难度。</li></ul></blockquote><h2 id="3-抽象工厂（Abstract-Factory）"><a href="#3-抽象工厂（Abstract-Factory）" class="headerlink" title="3.抽象工厂（Abstract Factory）"></a>3.抽象工厂（Abstract Factory）</h2><blockquote><p>抽象工厂模式是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。</p><p>工厂方法模式中考虑的是一类产品的生产，如电脑厂只生产电脑，电话厂只生产电话，这种工厂只生产同种类的产品，同种类产品称为同等级产品，也就是说，工厂方法模式只考虑生产同等级的产品，但是现实生活中许多工厂都是综合型工厂，能生产多等级（种类）的产品，如上面说的电脑和电话，本质上他们都属于电器，那么他们就能在电器厂里生产出来，而抽象工厂模式就将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，如上图所示纵轴是产品等级，也就是同一类产品；横轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</p></blockquote><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/blog2025/20250306003047400.png" alt="image-20250306003040838"></p><blockquote><p>抽象工厂模式的主要角色如下：</p><p>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。<br>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。<br>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。<br>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</p></blockquote><h3 id="3-1代码实现"><a href="#3-1代码实现" class="headerlink" title="3.1代码实现"></a>3.1代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 咖啡店 抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoffeeShopFactory</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 咖啡类</span></span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 甜点类</span></span><br><span class="line">    Dessert <span class="title function_">createDessert</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 美式风格工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeShopFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Americano</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cheesecake</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 意式风格工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItalyFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeShopFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cappuccino</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tiramisu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1总结"><a href="#3-1总结" class="headerlink" title="3.1总结"></a>3.1总结</h3><blockquote><p>适用场景：</p><ul><li>客户端（应用层）不依赖于产品类实例如何被创建和实现等细节。</li><li>强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。</li><li>提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li></ul><p>优点</p><ul><li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</li></ul><p>缺点</p><ul><li>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">工厂方法模式简单记录</summary>
    
    
    
    <category term="设计模式" scheme="https://www.zhen0w0.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://www.zhen0w0.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>全链路日志追踪</title>
    <link href="https://www.zhen0w0.cn/posts/67d682bd.html"/>
    <id>https://www.zhen0w0.cn/posts/67d682bd.html</id>
    <published>2025-03-07T00:42:17.000Z</published>
    <updated>2025-03-07T00:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-由来"><a href="#0-由来" class="headerlink" title="0.由来"></a>0.由来</h2><blockquote><p>由于前司并无完整的日志系统，之前对这方面内容并无详细了解，在熟悉了现公司日志系统时发现，在排查日志时无论是ELK的日志检索，还是灰度的日志文件，都发现每次完整的接口调用，每一步日志都会带上同一个TraceId，用以追踪整个借口请求链路，特此研究如何通过TraceId将分布式系统的日志链路串联起来。</p></blockquote><h2 id="1-MDC"><a href="#1-MDC" class="headerlink" title="1.MDC"></a>1.MDC</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><blockquote><p>MDC（Mapped Diagnostic Context，映射调试上下文）是 <strong>log4j</strong> 、<strong>logback</strong>、<strong>slf4j</strong>及<strong>log4j2</strong> 提供的一种方便在多线程条件下记录日志的功能。<strong>MDC</strong> 可以看成是一个<strong>与当前线程绑定的哈希表</strong>，可以往其中添加键值对。MDC 中包含的内容可以<strong>被同一线程中执行的代码所访问</strong>。</p><p>当前线程的子线程会继承其父线程中的 MDC 的内容。当需要记录日志时，只需要从 MDC 中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。对于一个 Web 应用来说，通常是在请求被处理的最开始保存这些数据。</p></blockquote><h3 id="1-2-常用API"><a href="#1-2-常用API" class="headerlink" title="1.2 常用API"></a>1.2 常用API</h3><blockquote><ul><li><strong>clear()</strong> ：移除所有MDC</li><li><strong>get (String key)</strong> ：获取当前线程MDC中指定key的值</li><li><strong>getContext()</strong> ：获取当前线程MDC的MDC</li><li><strong>put(String key, Object o)</strong> ：往当前线程的MDC中存入指定的键值对</li><li><strong>remove(String key)</strong> ：删除当前线程MDC中指定的键值对</li></ul></blockquote><h3 id="1-3-优点"><a href="#1-3-优点" class="headerlink" title="1.3 优点"></a>1.3 优点</h3><p>代码简洁，日志风格统一，链路清晰，不需要在log打印中手动拼写<strong>traceId</strong>，即<strong>LOGGER.info(“traceId:{} “, traceId)。</strong></p><h2 id="2-实现（单线程版）"><a href="#2-实现（单线程版）" class="headerlink" title="2.实现（单线程版）"></a>2.实现（单线程版）</h2><h3 id="2-1-相关依赖"><a href="#2-1-相关依赖" class="headerlink" title="2.1 相关依赖"></a>2.1 相关依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--lombok配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-log配置文件"><a href="#2-2-log配置文件" class="headerlink" title="2.2 log配置文件"></a>2.2 log配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志存储路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/Users/zhen/Downloads&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 控制台输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--输出格式化--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%X&#123;TRACE_ID&#125;]  %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 按天生成日志文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件名--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;log&#125;/%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%X&#123;TRACE_ID&#125;]  %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件最大的大小--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志输出级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-application-yml"><a href="#2-3-application-yml" class="headerlink" title="2.3 application.yml"></a>2.3 application.yml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">config:</span> <span class="string">classpath:logback-spring.xml</span></span><br></pre></td></tr></table></figure><h3 id="2-4-拦截器"><a href="#2-4-拦截器" class="headerlink" title="2.4 拦截器"></a>2.4 拦截器</h3><blockquote><p>用途：每一次链路，线程维度，添加最终的链路ID TRACE_ID。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.traceid.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.MDC;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Description: 请求拦截器（日志添加trace_id）</span></span><br><span class="line"><span class="comment">  * User: zhen0w0</span></span><br><span class="line"><span class="comment">  * Date: 2025/3/9</span></span><br><span class="line"><span class="comment">  * Time: 01:59</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TRACE_ID</span> <span class="operator">=</span> <span class="string">&quot;TRACE_ID&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">traceId</span> <span class="operator">=</span> UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(request.getHeader(TRACE_ID)))&#123;</span><br><span class="line">            traceId = request.getHeader(TRACE_ID);</span><br><span class="line">        &#125;</span><br><span class="line">        MDC.put(TRACE_ID, traceId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        MDC.remove(TRACE_ID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>配置中添加自定义拦截器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.traceid.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhen.studytotal.traceid.interceptor.LogInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 配置自定义web拦截器</span></span><br><span class="line"><span class="comment"> * User: zhen0w0</span></span><br><span class="line"><span class="comment"> * Date: 2025/3/9</span></span><br><span class="line"><span class="comment"> * Time: 02:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfigurerAdapter</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LogInterceptor <span class="title function_">logInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LogInterceptor</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.traceid.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: zhen0w0</span></span><br><span class="line"><span class="comment"> * Date: 2025/3/9</span></span><br><span class="line"><span class="comment"> * Time: 02:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/doTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doTest</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;调用开始 name=&#123;&#125;&quot;</span>, name);</span><br><span class="line">        log.info(<span class="string">&quot;这是一行info日志&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;这是一行error日志&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;调用结束 name=&#123;&#125;&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-效果展示"><a href="#2-6-效果展示" class="headerlink" title="2.6 效果展示"></a>2.6 效果展示</h3><blockquote><p>可以看出每次接口调用都有自己专属的trace_id</p></blockquote><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/blog2025/20250309181652146.png" alt="image-20250309181651971"></p><h2 id="3-实现（多线程版）"><a href="#3-实现（多线程版）" class="headerlink" title="3.实现（多线程版）"></a>3.实现（多线程版）</h2><blockquote><p>拦截器参考单线程版即可，主要应对异步线程之外的常规操作</p></blockquote><h3 id="3-1-生成trace-id工具类"><a href="#3-1-生成trace-id工具类" class="headerlink" title="3.1 生成trace_id工具类"></a>3.1 生成trace_id工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.traceid.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraceIdUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">TraceIdUtil</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;Utility class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取traceId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getTraceId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-MDC工具类"><a href="#3-2-MDC工具类" class="headerlink" title="3.2 MDC工具类"></a>3.2 MDC工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.traceid.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.MDC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: zhen0w0</span></span><br><span class="line"><span class="comment"> * Date: 2025/3/21</span></span><br><span class="line"><span class="comment"> * Time: 00:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMdcUtil</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LogConstant</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TRACE_ID</span> <span class="operator">=</span> <span class="string">&quot;TRACE_ID&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setTraceIdIfAbsent</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (MDC.get(LogConstant.TRACE_ID) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//插入唯一日志ID</span></span><br><span class="line">                MDC.put(LogConstant.TRACE_ID, TraceIdUtil.getTraceId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title function_">wrap</span><span class="params">(<span class="keyword">final</span> Callable&lt;T&gt; callable, <span class="keyword">final</span> Map&lt;String, String&gt; context)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">                    MDC.clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    MDC.setContextMap(context);</span><br><span class="line">                &#125;</span><br><span class="line">                setTraceIdIfAbsent();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> callable.call();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    MDC.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title function_">wrap</span><span class="params">(<span class="keyword">final</span> Runnable runnable, <span class="keyword">final</span> Map&lt;String, String&gt; context)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">                    MDC.clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    MDC.setContextMap(context);</span><br><span class="line">                &#125;</span><br><span class="line">                setTraceIdIfAbsent();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    MDC.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-重写线程池"><a href="#3-3-重写线程池" class="headerlink" title="3.3 重写线程池"></a>3.3 重写线程池</h3><blockquote><p>这一步借助MDC工具类，对线程池原有的execute等方法进行优化，使每次线程执行时都附带trace_id</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.traceid.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhen.studytotal.traceid.utils.ThreadMdcUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.MDC;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.concurrent.ListenableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorMdcWrapper</span> <span class="keyword">extends</span> <span class="title class_">ThreadPoolTaskExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showThreadPoolInfo</span><span class="params">(String prefix)</span>&#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> getThreadPoolExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span>==threadPoolExecutor)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;, &#123;&#125;,taskCount [&#123;&#125;], completedTaskCount [&#123;&#125;], activeCount [&#123;&#125;], queueSize [&#123;&#125;]&quot;</span>,</span><br><span class="line">                <span class="built_in">this</span>.getThreadNamePrefix(),</span><br><span class="line">                prefix,</span><br><span class="line">                threadPoolExecutor.getTaskCount(),</span><br><span class="line">                threadPoolExecutor.getCompletedTaskCount(),</span><br><span class="line">                threadPoolExecutor.getActiveCount(),</span><br><span class="line">                threadPoolExecutor.getQueue().size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;1. do execute&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.execute(ThreadMdcUtil.wrap(task, MDC.getCopyOfContextMap()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task, <span class="type">long</span> startTimeout)</span> &#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;2. do execute&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.execute(ThreadMdcUtil.wrap(task, MDC.getCopyOfContextMap()), startTimeout);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;1. do submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.submit(ThreadMdcUtil.wrap(task, MDC.getCopyOfContextMap()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;2. do submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.submit(ThreadMdcUtil.wrap(task, MDC.getCopyOfContextMap()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ListenableFuture&lt;?&gt; submitListenable(Runnable task) &#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;1. do submitListenable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.submitListenable(ThreadMdcUtil.wrap(task, MDC.getCopyOfContextMap()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; ListenableFuture&lt;T&gt; <span class="title function_">submitListenable</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">        showThreadPoolInfo(<span class="string">&quot;2. do submitListenable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.submitListenable(ThreadMdcUtil.wrap(task, MDC.getCopyOfContextMap()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-初始化线程池"><a href="#3-4-初始化线程池" class="headerlink" title="3.4 初始化线程池"></a>3.4 初始化线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhen.studytotal.traceid.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: zhen0w0</span></span><br><span class="line"><span class="comment"> * Date: 2025/3/21</span></span><br><span class="line"><span class="comment"> * Time: 00:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutorMdcWrapper <span class="title function_">asyncServiceExecutor</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;start asyncServiceExecutor&quot;</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutorMdcWrapper</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutorMdcWrapper</span>();</span><br><span class="line">        <span class="comment">//配置核心线程数</span></span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//配置最大线程数</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">//配置队列大小</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">99999</span>);</span><br><span class="line">        <span class="comment">//配置线程池中的线程的名称前缀</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;async-service-&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置拒绝策略：当pool已经达到max size的时候，如何处理新任务</span></span><br><span class="line">        <span class="comment">// CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="comment">//执行初始化</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-测试"><a href="#3-5-测试" class="headerlink" title="3.5 测试"></a>3.5 测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Executor executor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/logId&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">logId</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;调用开始------------------------------------ name=&#123;&#125;&quot;</span>, name);</span><br><span class="line">    log.info(<span class="string">&quot;这是一行info日志&quot;</span>);</span><br><span class="line">    log.error(<span class="string">&quot;这是一行error日志&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;调用结束 name=&#123;&#125;&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//ExecutorService executor = Executors.newSingleThreadExecutor();</span></span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;线程内日志&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello,&quot;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/blog2025/20250322024601777.png" alt="image-20250322024601603"></p><h2 id="4-分布式解决方案"><a href="#4-分布式解决方案" class="headerlink" title="4.分布式解决方案"></a>4.分布式解决方案</h2><blockquote><p>Sleuth</p><ul><li><p><a href="https://blog.csdn.net/aa2528877987/article/details/134459754?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522cfecea9f308170ed24f44d98bec5b708%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=cfecea9f308170ed24f44d98bec5b708&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-3-134459754-null-null.142^v102^pc_search_result_base5&amp;utm_term=sleuth&amp;spm=1018.2226.3001.4187">参考链接01</a></p></li><li><p><a href="https://blog.csdn.net/qq_32440951/article/details/80597187">参考链接02</a></p></li></ul></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">了解一个接口的所有日志如何做到共享一个TraceId</summary>
    
    
    
    <category term="实用功能" scheme="https://www.zhen0w0.cn/categories/%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
    <category term="实用功能" scheme="https://www.zhen0w0.cn/tags/%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>mybatis(order by)参数无法使用#包裹.</title>
    <link href="https://www.zhen0w0.cn/posts/b27989bb.html"/>
    <id>https://www.zhen0w0.cn/posts/b27989bb.html</id>
    <published>2025-02-18T22:13:58.000Z</published>
    <updated>2025-02-18T22:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>众所周知，mybatis中使用#号可以防止SQL注入，但是order by却不能使用#而必须使用$</p><p>Mybatis中如果使用#符引用参数，会自动在参数值两端加引号，导致排序失效，因此Mybatis中使用Order By时一定使用$符号</p><p>另外如果表名是参数，也要用$符，因为表名不允许使用引号，直接就会报语法错误。</p><p>用下表做参考</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t2` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`<span class="keyword">value</span>` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">)</span><br><span class="line">ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> <span class="keyword">value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="number">5</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="number">4</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>则下面两条SQL执行结果为何</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">order</span> <span class="keyword">by</span> <span class="string">&#x27;value&#x27;</span>; <span class="comment">-- 可以看出当使用引号时，输出结果并没有排序。</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">value</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> <span class="keyword">value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="number">4</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="number">5</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">order</span> <span class="keyword">by</span> <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> <span class="keyword">value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="number">5</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="number">4</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br></pre></td></tr></table></figure><blockquote><p>这是因为当order by后是字符串，MySQL会认为根据一个常量列排序，如下列代码所示：</p><p>而常量列所有值都相等，所以也就不会排序。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> id,<span class="keyword">value</span>,<span class="string">&#x27;value&#x27;</span> <span class="keyword">from</span> t2 <span class="keyword">order</span> <span class="keyword">by</span> <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> <span class="keyword">value</span> <span class="operator">|</span> <span class="keyword">value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="number">5</span>     <span class="operator">|</span> <span class="keyword">value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="number">4</span>     <span class="operator">|</span> <span class="keyword">value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span> <span class="keyword">value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span> <span class="keyword">value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span> <span class="keyword">value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+-------+</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">mybatis中关于order by参数的小坑</summary>
    
    
    
    <category term="Mbatis" scheme="https://www.zhen0w0.cn/categories/Mbatis/"/>
    
    
    <category term="Mybatis" scheme="https://www.zhen0w0.cn/tags/Mybatis/"/>
    
    <category term="SQL" scheme="https://www.zhen0w0.cn/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>MVCC独家见解</title>
    <link href="https://www.zhen0w0.cn/posts/69844b49.html"/>
    <id>https://www.zhen0w0.cn/posts/69844b49.html</id>
    <published>2025-02-11T17:38:00.000Z</published>
    <updated>2025-02-11T06:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>首先复习一下MVCC原理，详细内容可参考<br><a href="https://blog.csdn.net/SnailMann/article/details/94724197?ops_request_misc=%257B%2522request%255Fid%2522%253A%252212bd27ee19cc80b92b9f12e7bccbdd40%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=12bd27ee19cc80b92b9f12e7bccbdd40&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-94724197-null-null.142^v102^pc_search_result_base1&amp;utm_term=mvcc&amp;spm=1018.2226.3001.4187">【MySQL笔记】正确的理解MySQL的MVCC及实现原理_mysqlmvcc实现原理-CSDN博客</a></p></blockquote><h2 id="1-疑问点一"><a href="#1-疑问点一" class="headerlink" title="1.疑问点一"></a>1.疑问点一</h2><blockquote><p>关于上述blog中 <code>RR 是如何在 RC 级的基础上解决不可重复读的</code> 的解释，个人认为比较抽象，这里记录个人理解</p></blockquote><p>Read View源码中大致包含以下内容（具体名称可能与上述博客有出入，代指含义基本相同上述博客中的字段名是作者自己取的是🐶）</p><ul><li><code>m_ids</code>：创建 Read View 时，系统内<strong>活跃</strong>（尚未提交）的事务 ID 集合。</li><li><code>min_trx_id</code>：<code>m_ids</code> 中的最小值。</li><li><code>max_trx_id</code>：创建 Read View 时，系统应该分配给下一个事务的 ID 值（即当前最大事务 ID + 1）。</li><li><code>creator_trx_id</code>：创建该 Read View 的事务自身的 ID（对于只读事务，可能为 0）。</li></ul><p>==RR级别下假设的事务执行流程==：</p><ol><li><strong>事务开始：</strong> 假设事务 T1 (ID=100) 开始</li><li><strong>第一次 SELECT (创建 Read View)</strong>：<ul><li>T1 执行 <code>SELECT * FROM t WHERE id = 1;</code></li><li>MySQL 为 T1 <strong>创建 Read View RV1</strong>：<ul><li><code>m_ids</code> = 活跃事务列表，比如 50, 80 (假设活跃事务ID为50和80)</li><li><code>min_trx_id</code> = 50</li><li><code>max_trx_id</code> = 101 (下一个事务ID，最新事务为T1  ID=100)</li><li><code>creator_trx_id</code> = 100</li></ul></li><li>根据 RV1 和行 <code>id=1</code> 的版本链，找到对 T1 可见的版本（假设是事务 40 提交的版本 <code>V1</code>），返回 <code>V1</code> 的数据。</li></ul></li><li><strong>并发修改</strong>：此时另一个事务 T2 (ID=80) <strong>更新</strong>了 <code>id=1</code> 这行数据（生成新版本 <code>V2</code>，<code>DB_TRX_ID=80</code>）并<strong>提交</strong>。</li><li><strong>第二次 SELECT (复用 Read View)：</strong><ul><li>T1 再次执行 <code>SELECT * FROM t WHERE id = 1;</code></li><li>关键点：<strong>T1 复用第一次查询时创建的 Read View RV1</strong>。RV1 的 <code>m_ids</code> 仍然记录的是创建时的活跃事务 50-80（尽管 T2=80 现在已经提交了）</li><li>遍历行 <code>id=1</code> 的版本链：<ul><li>最新版本是 <code>V2</code> (<code>DB_TRX_ID=80</code>)</li><li>检查 <code>V2</code> 对 RV1 是否可见：<ul><li><code>80</code> 在 <code>min_trx_id</code> (50) 和 <code>max_trx_id</code> (101) 之间</li><li><code>80</code> <strong>在</strong> RV1 的 <code>m_ids</code> (包含 80) 中 -&gt; <strong>不可见</strong></li></ul></li><li>继续查找上一个版本 <code>V1</code> (<code>DB_TRX_ID=40</code>)</li><li>检查 <code>V1</code>：<ul><li><code>40</code> <strong>小于</strong> <code>min_trx_id</code> (50) -&gt; <strong>可见</strong>。</li></ul></li></ul></li></ul></li></ol><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/blog2025/20250714205416487.png" alt="image-20250714205416443"></p><blockquote><p>==总结==：本质上是保证了在当前事务内，每次读取某条记录得到的结果永远一致，由此引出了疑问点二</p></blockquote><h2 id="2-疑问点二s"><a href="#2-疑问点二s" class="headerlink" title="2.疑问点二ß"></a>2.疑问点二ß</h2><blockquote><p>从上面的例子来看，事务T1两次读取的都是V1版本的快照，但是事务T2已经将数据修改为另一个版本，这样数据有差异会不会引起什么问题</p></blockquote><h3 id="1-RR-的核心目标：事务内部的“时间凝固”"><a href="#1-RR-的核心目标：事务内部的“时间凝固”" class="headerlink" title="1. RR 的核心目标：事务内部的“时间凝固”"></a>1. RR 的核心目标：事务内部的“时间凝固”</h3><ul><li><strong>设计意图：</strong> RR 隔离级别保证：<strong>在同一个事务内部，多次读取同一行数据，看到的结果是绝对一致的（可重复读）</strong>。即使外部世界（其他事务）已经修改并提交了数据。</li><li><strong>实现方式：</strong> 如前所述，通过在整个事务中<strong>复用第一次 <code>SELECT</code> 时创建的 Read View</strong>，使得该事务<strong>永远只能看到这个“快照时间点”之前已提交的数据</strong>（以及它自身所做的修改）。对于该事务来说，时间仿佛在它第一次读数据时就凝固了。</li><li><p>疑问：<strong> 在 T1 的视角里，它两次读取 <code>id=1</code> 看到的都是 V1（事务40提交的版本）。</strong>T2 提交的 V2 版本对于 T1 来说“不存在”或者说“尚未发生”**。T1 的世界观停留在它开始读取的那个瞬间。这就是“可重复读”的含义。</p><h3 id="2-为什么这种“差异”在-RR-下是可以接受的-设计的？"><a href="#2-为什么这种“差异”在-RR-下是可以接受的-设计的？" class="headerlink" title="2. 为什么这种“差异”在 RR 下是可以接受的/设计的？"></a>2. 为什么这种“差异”在 RR 下是可以接受的/设计的？</h3></li><li><p><strong>业务场景需求：</strong> 很多业务逻辑<strong>需要</strong>在事务执行期间看到一个<strong>稳定的、不受外部干扰的数据视图</strong>。例如：</p><ul><li><strong>金融对账：</strong> 在计算账户余额、生成报表时，需要基于某个固定时间点的数据快照进行计算。如果在计算过程中基础数据（如账户余额）被其他事务修改，会导致结果混乱且不可审计。</li><li><strong>一致性决策：</strong> 一个事务可能需要基于之前查询的结果集做后续操作。如果两次查询结果不一致（不可重复读），可能导致逻辑错误。RR 保证了决策依据的稳定性。</li><li><strong>长事务分析：</strong> 分析型查询可能需要扫描大量数据，耗时较长。RR 保证在整个扫描过程中看到的是同一份数据快照，结果具有内部一致性。</li></ul></li><li><strong>隔离性的代价：</strong> 数据库的隔离级别本质上是<strong>在并发性能和数据一致性/时效性之间做权衡</strong>。RR 牺牲了在事务执行期间看到其他事务最新提交数据的<strong>时效性</strong>，换取了事务内部读取数据的<strong>强一致性（可重复读）</strong>。</li><li><strong>“过时”≠“错误”：</strong> T1 看到的 V1 版本，在它第一次读取时是<strong>真实且已提交</strong>的状态。RR 只是保证了 T1 在整个生命周期内看到的都是这个<strong>曾经真实存在过的、符合其时间点一致性</strong>的状态。这不是一个“错误”的数据，而是一个“历史”的数据。</li></ul><h3 id="3-这种“差异”何时会成为问题？如何解决？"><a href="#3-这种“差异”何时会成为问题？如何解决？" class="headerlink" title="3. 这种“差异”何时会成为问题？如何解决？"></a>3. 这种“差异”何时会成为问题？如何解决？</h3><p>虽然 RR 解决了不可重复读，但刻意维持旧视图的行为确实可能在特定场景下引发问题或需要额外注意：</p><ol><li><p><strong>写操作基于“过时”视图 (Lost Update / Write Skew)：</strong></p><ul><li><strong>场景：</strong> T1 读取 V1（余额=100），T2 也读取 V1（余额=100）。T2 基于 V1 计算并更新余额为 80（生成 V2）提交。T1 也基于它读到的 V1（100）计算并尝试更新余额为 120。</li><li><strong>问题：</strong> 如果直接让 T1 的更新覆盖 T2 的更新（变成 120），那么 T2 的更新就丢失了（Lost Update）。数据库应该期望最终余额是 80 还是 120？逻辑上都不对。</li><li>==<strong>RR 的解决机制 (Next-Key Lock / 行锁)：</strong>==<ul><li>MySQL InnoDB 的 RR 级别不仅依赖 MVCC 的快照读，还对写操作（UPDATE, DELETE）和显式加锁读（<code>SELECT ... FOR UPDATE/SHARE</code>) 使用 <strong>锁机制 (Next-Key Locking)</strong>。</li><li>当 T1 执行 <code>UPDATE t SET balance = 120 WHERE id = 1;</code> 时：<ul><li>它<strong>不会</strong>直接去修改它看到的 V1 版本。</li><li>它会尝试<strong>获取行 id=1 的排他锁 (X Lock)</strong>。</li><li>如果 T2 已经提交（锁已释放），T1 能获得锁。</li><li>但关键点：<strong>在修改之前，InnoDB 会执行 “当前读” (Current Read)</strong>。它会读取该行的<strong>最新已提交版本 (V2, balance=80)</strong>，而不是 T1 Read View 中的 V1！(这是 MVCC 快照读和写操作的“当前读”的重要区别！)。</li><li>T1 的 UPDATE 操作会<strong>基于这个最新提交的 V2 (80)</strong> 来计算新值。假设业务逻辑是 <code>balance = balance - 20</code>，那么：<ul><li>如果基于 V1(100) 计算：100 - 20 = 80 (错误，因为实际最新是80)。</li><li>但引擎基于<strong>当前读</strong>到的 V2(80) 计算：80 - 20 = 60。</li></ul></li><li>然后生成新版本 V3 (trx_id=100, balance=60)。</li></ul></li><li><strong>结果：</strong> T2 的更新（80）没有被覆盖，T1 的更新是基于最新状态（80）计算的（60）。避免了更新丢失。最终结果符合逻辑（先减到80，再减到60）。</li><li><strong>结论：</strong> RR 级别下，<strong>写操作总是基于最新的已提交数据</strong>，不受本事务 Read View 快照的影响。这解决了基于“过时”视图写数据可能导致的问题。快照读看到的“旧”数据和写操作需要的“新”数据通过锁和“当前读”机制协调。</li></ul></li></ul></li><li><p><strong>需要读取最新数据：</strong></p><ul><li><strong>场景：</strong> 如果业务逻辑要求在一个事务内必须读取到其他事务提交的最新数据（例如实时监控、某些类型的通知）。</li><li><strong>解决方案：</strong><ul><li><strong>降低隔离级别到 RC：</strong> 每次 SELECT 都会看到最新提交的数据。但会面临不可重复读和幻读。</li><li><strong>在 RR 中使用 <code>FOR UPDATE</code> / <code>LOCK IN SHARE MODE</code>：</strong> 这些加锁读会执行“当前读”，直接获取最新已提交版本并加锁，绕过 Read View 快照。</li><li><strong>使用 <code>SELECT ... FOR UPDATE</code>：</strong> <code>SELECT * FROM t WHERE id = 1 FOR UPDATE;</code> (获取排他锁，执行当前读，看到 V2)。</li><li><strong>使用 <code>SELECT ... LOCK IN SHARE MODE</code>：</strong> <code>SELECT * FROM t WHERE id = 1 LOCK IN SHARE MODE;</code> (获取共享锁，执行当前读，看到 V2)。</li><li><strong>执行写操作 (UPDATE/DELETE)：</strong> 如前所述，写操作本身就会触发“当前读”。</li></ul></li></ul></li></ol><blockquote><p>==总结==：T1内部在进行select操作时，采用的时快照读，这个快照始终是V1版本数据，但是如果T1内部进行了update操作，在进行类似balance = balance-20的操作时，采取的时当前读，只会有一个事务拿到该记录的排他锁，若T2优先获得排他锁，T1更新的必然是T2操作完之后的数据。因此不存在更新操作冲突</p></blockquote>]]></content>
    
    
    <summary type="html">解惑自己在重新深入一遍MVCC之后的新疑问</summary>
    
    
    
    <category term="Mysql" scheme="https://www.zhen0w0.cn/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.zhen0w0.cn/tags/Mysql/"/>
    
    <category term="MVCC" scheme="https://www.zhen0w0.cn/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>零拷贝相关内容</title>
    <link href="https://www.zhen0w0.cn/posts/3603bbb3.html"/>
    <id>https://www.zhen0w0.cn/posts/3603bbb3.html</id>
    <published>2025-01-16T23:47:39.000Z</published>
    <updated>2025-01-16T23:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h1 id="传统IO">传统IO</h1><h2 id="概览">概览</h2><blockquote><p><code>read</code>：把数据从磁盘读取到内核缓冲区，再拷贝到用户缓冲区<br><code>write</code>：先把数据写入到 socket缓冲区，最后写入网卡设备</p></blockquote><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/blog2025/20250116233135350.png" alt="image-20250116233129826"></p><p><code>DMA（Direct Memory Access，直接内存访问）：DMA 本质上是一块主板上独立的芯片，允许外设设备直接与内存存储器进行数据传输，并且不需要CPU参与的技术</code></p><blockquote><ol><li>用户空间的应用程序通过read()函数，向操作系统发起IO调用，上下文从用户态到切换到内核态，然后再通过 DMA 控制器将数据从磁盘文件中读取到内核缓冲区</li><li>接着CPU将内核空间缓冲区的数据拷贝到用户空间的数据缓冲区，然后read系统调用返回，而系统调用的返回又会导致上下文从内核态切换到用户态</li><li>用户空间的应用程序通过write()函数向操作系统发起IO调用，上下文再次从用户态切换到内核态；接着CPU将数据从用户缓冲区复制到内核空间的 socket 缓冲区（也是内核缓冲区，只不过是给socket使用），然后write系统调用返回，再次触发上下文切换</li><li>最后异步传输socket缓冲区的数据到网卡，也就是说write系统调用的返回并不保证数据被传输到网卡</li></ol></blockquote><h2 id="小结">小结</h2><blockquote><p>在传统的数据 IO 模式中，读取一个磁盘文件，并发送到远程端的服务，就共有==四次用户空间与内核空间的上下文切换==，四次数据复制，包括两次 CPU 数据复制，两次 DMA 数据复制。但两次 CPU 数据复制才是最消耗资源和时间的，这个过程还需要内核态和用户态之间的来回切换，而CPU资源十分宝贵，要拷贝大量的数据，还要处理大量的任务，如果能把 CPU 的这两次拷贝给去除掉，既能节省CPU资源，还可以避免内核态和用户态之间的切换。而零拷贝技术就是为了解决这个问题</p></blockquote><h1 id="零拷贝">零拷贝</h1><h2 id="概览-2">概览</h2><blockquote><p>零拷贝指在进行数据 IO 时，数据在用户态下经历了零次 CPU 拷贝，并非不拷贝数据。通过减少数据传输过程中 内核缓冲区和用户进程缓冲区 间不必要的CPU数据拷贝 与 用户态和内核态的上下文切换次数，降低 CPU 在这两方面的开销，释放 CPU 执行其他任务，更有效的利用系统资源，提高传输效率，同时还减少了内存的占用，也提升应用程序的性能。</p><p>由于零拷贝在内核空间中完成所有的内存拷贝，可以最大化使用 socket 缓冲区的可用空间，从而提高了一次系统调用中处理的数据量，进一步降低了上下文切换次数。零拷贝技术基于 PageCache，而 PageCache 缓存了最近访问过的数据，提升了访问缓存数据的性能，同时，为了解决机械磁盘寻址慢的问题，它还协助 IO 调度算法实现了 IO 合并与预读（这也是顺序读比随机读性能好的原因），这进一步提升了零拷贝的性能。</p></blockquote><h2 id="实现方式-Linux">实现方式(Linux)</h2><h3 id="1-mmap-write">1.mmap + write</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;sys/mman.h&gt;</span></span><br><span class="line">void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset)</span><br></pre></td></tr></table></figure><ul><li>addr：指定映射的虚拟内存地址</li><li>length：映射的长度</li><li>prot：映射内存的保护模式</li><li>flags：指定映射的类型</li><li>fd:进行映射的文件句柄</li><li>offset:文件偏移量</li></ul><blockquote><p>在传统 IO 模式的4次内存拷贝中，与物理设备相关的2次拷贝（把磁盘数据拷贝到内存 以及 把数据从内存拷贝到网卡）是必不可少的。但与用户缓冲区相关的2次拷贝都不是必需的，如果内核在读取文件后，直接把内核缓冲区中的内容拷贝到 Socket 缓冲区，待到网卡发送完毕后，再通知进程，这样就可以减少一次 CPU 数据拷贝了。而 <code>内存映射mmap</code> 就是通过前面介绍的方式实现零拷贝的，它的核心就是<code>操作系统把内核缓冲区与应用程序共享，将一段用户空间内存映射到内核空间，当映射成功后，用户对这段内存区域的修改可以直接反映到内核空间；同样地，内核空间对这段区域的修改也直接反映用户空间。正因为有这样的映射关系, 就不需要在用户态与内核态之间拷贝数据</code>， 提高了数据传输的效率，这就是内存直接映射技术。具体示意图如下：</p></blockquote><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/blog2025/20250116233204248.png" alt="image-20250116233204181"></p><p><code>mmap 的零拷贝 I/O 进行了4次用户空间与内核空间的上下文切换，以及3次数据拷贝；其中3次数据拷贝中包括了2次 DMA 拷贝和1次 CPU 拷贝。所以 mmap 通过内存地址映射的方式，节省了数据IO过程中的一次CPU数据拷贝以及一半的内存空间</code></p><blockquote><ol><li>用户应用程序通过 mmap() 向操作系统发起 IO调用，上下文从用户态切换到内核态；然后通过 DMA 将数据从磁盘中复制到内核空间缓冲区</li><li>mmap 系统调用返回，上下文从内核态切换回用户态（这里不需要将数据从内核空间复制到用户空间，因为用户空间和内核空间共享了这个缓冲区）</li><li>用户应用程序通过 write() 向操作系统发起 IO调用，上下文再次从用户态切换到内核态。接着 CPU 将数据从内核空间缓冲区复制到内核空间 socket 缓冲区；write 系统调用返回，导致内核空间到用户空间的上下文切换</li><li>DMA 异步将 socket 缓冲区中的数据拷贝到网卡</li></ol></blockquote><h3 id="2-sendfile">2.sendfile</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;sys/sendfile.h&gt;</span></span><br><span class="line">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br></pre></td></tr></table></figure><ul><li>out_fd:为待写入内容的文件描述符，一个socket描述符。，</li><li>in_fd:为待读出内容的文件描述符，必须是真实的文件，不能是socket和管道。</li><li>offset：指定从读入文件的哪个位置开始读，如果为NULL，表示文件的默认起始位置。</li><li>count：指定在fdout和fdin之间传输的字节数。</li></ul><blockquote><p>只要我们的代码执行 read 或者 write 这样的系统调用，一定会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。因此，如果想减少上下文切换次数，就一定要减少系统调用的次数，解决方案就是把 read、write 两次系统调用合并成一次，在内核中完成磁盘与网卡的数据交换。在 Linux 2.1 版本内核开始引入的 sendfile 就是通过这种方式来实现零拷贝的，见下图：</p></blockquote><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/blog2025/20250116233224374.png" alt="image-20250116233224306"></p><blockquote><ol><li>用户应用程序发出 sendfile 系统调用，上下文从用户态切换到内核态；然后通过 DMA 控制器将数据从磁盘中复制到内核缓冲区中</li><li>然后CPU将数据从内核空间缓冲区复制到 socket 缓冲区</li><li>sendfile 系统调用返回，上下文从内核态切换到用户态</li><li>DMA 异步将内核空间 socket 缓冲区中的数据传递到网卡</li></ol></blockquote><p><code>通过 sendfile 实现的零拷贝I/O使用了2次用户空间与内核空间的上下文切换，以及3次数据的拷贝。其中3次数据拷贝中包括了2次DMA拷贝和1次CPU拷贝。那能不能将CPU拷贝的次数减少到0次呢？答案肯定是有的，那就是 带 DMA 收集拷贝功能的 sendfile</code></p><h3 id="3-带DMA收集拷贝功能的sendfile">3.带DMA收集拷贝功能的sendfile</h3><blockquote><p>Linux 2.4 版本之后，对 sendfile 做了升级优化，引入了 SG-DMA技术，其实就是对DMA拷贝加入了 scatter/gather 操作，它可以直接从内核空间缓冲区中将数据读取到网卡，无需将内核空间缓冲区的数据再复制一份到 socket 缓冲区，从而省去了一次 CPU拷贝。具体流程如下：</p></blockquote><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/blog2025/20250116233543797.png" alt="image-20250116233543733"></p><p><code> 带有 DMA 收集拷贝功能的 sendfile 实现的 I/O 使用了2次用户空间与内核空间的上下文切换，以及2次数据的拷贝，而且这2次的数据拷贝都是非CPU拷贝，这样就实现了最理想的零拷贝I/O传输了，不需要任何一次的CPU拷贝，以及最少的上下文切换</code></p><blockquote><ol><li>用户应用程序发出 sendfile 系统调用，上下文从用户态切换到内核态；然后通过 DMA 控制器将数据从磁盘中复制到内核缓冲区中</li><li>接下来不需要CPU将数据复制到 socket 缓冲区，而是将相应的文件描述符信息复制到 socket 缓冲区，该描述符包含了两种的信息：①<code>内核缓冲区的内存地址</code>②<code>内核缓冲区的偏移量</code></li><li>sendfile 系统调用返回，上下文从内核态切换到用户态</li><li>DMA 根据 socket 缓冲区中描述符提供的地址和偏移量直接将内核缓冲区中的数据复制到网卡</li></ol></blockquote><p><code>需要注意的是，零拷贝有一个缺点，就是不允许进程对文件内容作一些加工再发送，比如数据压缩后再发送</code></p><h2 id="应用场景">应用场景</h2><h3 id="1-JAVA-NIO">1.JAVA-NIO</h3><h4 id="mmap-write">mmap + write</h4><blockquote><p>FileChannel 的 map() 方法产生的 MappedByteBuffer：FileChannel 提供了 map() 方法，该方法可以在一个打开的文件和 MappedByteBuffer 之间建立一个虚拟内存映射，MappedByteBuffer 继承于 ByteBuffer；该缓冲器的内存是一个文件的内存映射区域。map() 方法底层是通过 mmap 实现的，因此将文件内存从磁盘读取到内核缓冲区后，用户空间和内核空间共享该缓冲区。mmap的demo如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MmapTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">readChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;./jay.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">            <span class="type">MappedByteBuffer</span> <span class="variable">data</span> <span class="operator">=</span> readChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">40</span>);</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">writeChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;./siting.txt&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line">            <span class="comment">//数据传输</span></span><br><span class="line">            writeChannel.write(data);</span><br><span class="line">            readChannel.close();</span><br><span class="line">            writeChannel.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sendfile">sendfile</h4><blockquote><p>FileChannel 的 transferTo、transferFrom 如果操作系统底层支持的话，transferTo、transferFrom也会使用 sendfile 零拷贝技术来实现数据的传输</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">transferFrom</span><span class="params">(FileChannel fileChannel, <span class="type">long</span> position, <span class="type">long</span> count)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="keyword">return</span> fileChannel.transferTo(position, count, socketChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>sendfile 的 demo 如下:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendFileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">readChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;./jay.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">            <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> readChannel.size();</span><br><span class="line">            <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> readChannel.position();</span><br><span class="line">            </span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">writeChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;./siting.txt&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line">            <span class="comment">//数据传输</span></span><br><span class="line">            readChannel.transferTo(position, len, writeChannel);</span><br><span class="line">            readChannel.close();</span><br><span class="line">            writeChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Netty">2.Netty</h3><blockquote><ol><li>在网络通信上，Netty 的接收和发送 ByteBuffer 采用直接内存，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中（为什么拷贝？因为 JVM 会发生 GC 垃圾回收，数据的内存地址会发生变化，直接将堆内的内存地址传给内核，内存地址一旦变了就内核读不到数据了），然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</li><li>在文件传输上，Netty 的通过 FileRegion 包装的 FileChannel.tranferTo 实现文件传输，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</li><li>在缓存操作上，Netty 提供了CompositeByteBuf 类，它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免了各个 ByteBuf 之间的拷贝。</li><li>通过 wrap 操作，我们可以将byte[]数组、ByteBuf、ByteBuffer等包装成一个Netty ByteBuf对象，进而避免了拷贝操作。</li><li>ByteBuf 支持 slice 操作，因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf，避免了内存的拷贝。</li></ol></blockquote><h3 id="3-kafka">3.kafka</h3><p><code>Kafka 的索引文件使用的是 mmap + write 方式，数据文件使用的是 sendfile 方式</code></p>]]></content>
    
    
    <summary type="html">简单了解零拷贝与普通IO的区别，与零拷贝的实现方式</summary>
    
    
    
    <category term="IO" scheme="https://www.zhen0w0.cn/categories/IO/"/>
    
    
    <category term="IO" scheme="https://www.zhen0w0.cn/tags/IO/"/>
    
    <category term="性能优化" scheme="https://www.zhen0w0.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>List的contains导致cpu飙高</title>
    <link href="https://www.zhen0w0.cn/posts/e3d794fc.html"/>
    <id>https://www.zhen0w0.cn/posts/e3d794fc.html</id>
    <published>2024-04-18T12:54:00.000Z</published>
    <updated>2024-04-18T12:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BUG背景">BUG背景</h2><blockquote><p>订单客户生产令号去重汇总</p><p>在开发过程中用到了List，随着业务需求的变化，需要去重。当时直接就在代码中判断是否包含 <code>list.contains(&quot;a&quot;)</code> ，包含则不添加</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 获取所有订单</span></span><br><span class="line">      List&lt;String&gt; allOrder = getAllOrders();</span><br><span class="line"><span class="comment">// 生产令号去重后数据</span></span><br><span class="line">      List&lt;String&gt; matchList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (String idno:allIdnos)&#123;</span><br><span class="line">          <span class="comment">// ...省略。isMatch </span></span><br><span class="line">          <span class="comment">// 匹配列表不包含用户id，才添加进匹配列表中</span></span><br><span class="line">          <span class="keyword">if</span> ( !matchList.contains(idno))&#123;</span><br><span class="line">              matchList.add(idno);</span><br><span class="line">          &#125; </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="问题解析">问题解析</h2><blockquote><p>由于getAllOrders获取到的订单数据量过于庞大，每添加一个都要做一便contains 操作的时候，其实他相当于做了一次遍历。时间复杂度是O（n）。那么要查找每个数据是否包含的话，就需要<code>n*n</code>次操作。最终导致CPU100%</p></blockquote><h2 id="改进">改进</h2><blockquote><p>改用set，set查找某一个元素的复杂度为O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有订单</span></span><br><span class="line">List&lt;String&gt; allOrder = getAllOrders();</span><br><span class="line"><span class="comment">// 生产令号去重后数据</span></span><br><span class="line">Set&lt;String&gt; matchSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String idno:allIdnos)&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !matchSet.contains(idno))&#123;</span><br><span class="line">        matchSet.add(idno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><blockquote><p>写代码的时候要选择合适的数据结构，考虑算法复杂度。在数据量大的时候差别明显</p><ul><li>ArrayList本质就是通过数组实现的，查找一个元素是否包含要用到遍历，时间复杂度是O(n)</li><li>HashSetHashSet的查找是通过HashMap的KeySet来实现的，判断是否包含某个元素的实现，时间复杂度是O(1)</li></ul></blockquote>]]></content>
    
    
    <summary type="html">list.contains(&quot;a&quot;)方法引起的cpu使用率飙升，导致服务端其他接口不可用</summary>
    
    
    
    <category term="Bug" scheme="https://www.zhen0w0.cn/categories/Bug/"/>
    
    
    <category term="性能优化" scheme="https://www.zhen0w0.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Bug" scheme="https://www.zhen0w0.cn/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>Refresh Token以及Token刷新</title>
    <link href="https://www.zhen0w0.cn/posts/44487efe.html"/>
    <id>https://www.zhen0w0.cn/posts/44487efe.html</id>
    <published>2024-04-10T12:54:00.000Z</published>
    <updated>2024-04-10T12:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Refresh-Token">Refresh Token</h1><blockquote><p>在JWT token中，refreshToken的作用主要是避免token过期时，前端用户突然退出登录产生不良体验。<br>试想，如果你正访问某基于jwt token机制的网站，该网站token过期时间是24小时，你在23小时59分前已经登录过了，现在你访问某页面时，正好处于token过期时间24小时的临界点，这时token突然过期，你上一秒看视频正起劲儿呢，下一秒就让你重新登录了，你说气不气？这时候如果有一个refreshToken，虽然正式的token过期了，但前端却可以拿这个refreshToken来主动续期。这样就解决了token过期导致用户上一秒还在登录，下一秒就突然退出登录的问题。</p></blockquote><p><em><strong>如何实现通过refreshToken刷新token</strong></em></p><blockquote><ol><li>首先，refreshToken有效时间一定要比token有效时间长至少才能不影响用户体验，具体要长多少得以实际需求为准，建议是24小时</li><li>前端每次访问后端都携带token，如果token失效则后端直接返回类似token失效请重新登录的报文。</li><li>前端第一次收到token失效的响应后，从本地存储拿refreshToken再去请求</li><li>后端一检测到refreshToken参数不为空，就去校验解析这个refreshToken</li></ol><ul><li>如果有效，后端就返回一个新的token及refreshToken给前端，前端收到后更新本地存储，同时拿这个新的token向后端发起第三次请求，然后成功获取资源</li><li>如果无效，则后端同样返回token失效，前端第二次收到失效的响应则跳转到登录页重新登录</li></ul></blockquote><h1 id="Token-刷新并发处理解决方案">Token 刷新并发处理解决方案</h1><blockquote><p>对 Token 进行刷新续期，我们要解决<strong>并发请求导致重复刷新 Token</strong> 的问题</p></blockquote><h2 id="利用-Redis-缓存">利用 Redis 缓存</h2><blockquote><p>当同时发起多个请求时，第一个接口刷新了 Token，后面的请求仍然能通过请求，且不造成 Token 重复刷新。那么，后端在用户第一次登录时，需要将生成的 Token 数据（token 和 createTime）缓存一份到 Redis 中。</p></blockquote><blockquote><p>当 Token 过期时，重新生成新的 Token 数据并更新 Redis 缓存，同时在 Redis 中设置一条 Token 过渡数据并设置一个很短的过期时间（比如 30s）。如果后面的请求发现 Token 已经被刷新了，就判断 Redis 中是否存在 Token 过渡数据，存在就放行，这样同一时间的请求都可以通过</p></blockquote><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/ArticleCover/20201203203907341.png" alt=""></p>]]></content>
    
    
    <summary type="html">关于token过期刷新问题及解决方案</summary>
    
    
    
    <category term="Bug" scheme="https://www.zhen0w0.cn/categories/Bug/"/>
    
    
    <category term="性能优化" scheme="https://www.zhen0w0.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Bug" scheme="https://www.zhen0w0.cn/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>集合汇总</title>
    <link href="https://www.zhen0w0.cn/posts/c772d64.html"/>
    <id>https://www.zhen0w0.cn/posts/c772d64.html</id>
    <published>2024-04-04T15:56:00.000Z</published>
    <updated>2024-04-04T15:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ArrayList">ArrayList</h2><h3 id="注意事项">注意事项</h3><ol><li><code>permits all elements, including null</code> , ArrayList 可以加入null（空值）,并且可以是多个。</li><li>ArrayList是由数组来实现数据存储的</li><li>ArrayList基本等同于Vector，除了ArrayList是线程不安全(执行效率高)。<strong>在多线程情况下，不建议使用ArrayList</strong>。</li></ol><h3 id="底层操作机制源码分析">底层操作机制源码分析</h3><ol><li>ArrayList中维护了一个Object类型的数组elementData</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">//transient表示瞬间,短暂的,表示该属性不会被序列号</span></span><br></pre></td></tr></table></figure><ol start="2"><li>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为<code>10</code>，如需要再次扩容，则扩容elementData为<strong>1.5倍</strong>。</li><li>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容,则直接扩容elementData为<strong>1.5倍</strong>。</li></ol><h4 id="无参构造器">无参构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>add方法</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;  </span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></span><br><span class="line">    elementData[size++] = e;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>ensureCapacityInternal  —&gt;  calculateCapacity</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;  </span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);  </span><br><span class="line">    &#125;    <span class="keyword">return</span> minCapacity;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有参构造器">有参构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity]; <span class="comment">//创建一个指定大小elementData数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+  </span><br><span class="line">                                           initialCapacity);  </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="扩容流程">扩容流程</h4><p><em><strong>add</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;  </span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></span><br><span class="line">    elementData[size++] = e;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>ensureCapacityInternal</strong></em></p><blockquote><p><code>calculateCapacity</code>界定所需数组大小</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;  </span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>ensureExplicitCapacity</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;  </span><br><span class="line">    modCount++;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//所需数组大于当前数组-&gt; 扩容 </span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)  </span><br><span class="line">        grow(minCapacity);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>grow</strong></em></p><blockquote><p>最终调用<code>Arrays.copyOf</code>方法对原数组扩容</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;  </span><br><span class="line"><span class="comment">//原数组大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">//扩容1.5倍（old + 0.5old)  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  </span><br><span class="line">        newCapacity = minCapacity;  </span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)  </span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);  </span><br><span class="line"></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并发替代方案">并发替代方案</h3><blockquote><ol><li><strong>Vector</strong>（两倍扩容）</li></ol><ul><li>Vector 用的不多，因为每次对添加的元素上锁，而且使用的是重量级锁synchronized是十分占用资源的，效率低下</li></ul><ol start="2"><li><strong>Collections</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br></pre></td></tr></table></figure><ol start="3"><li>CopyOnWriteArrayList</li></ol><ul><li><strong>写时复制技术</strong></li><li>读的时候并发（多个线程操作）</li><li>写的时候独立，先复制相同的空间到某个区域，将其写到新区域，旧新合并，并且读新区域（每次加新内容都写到新区域，覆盖合并之前旧区域，读取新区域添加的内容）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></blockquote><h2 id="HashMap">HashMap</h2><h3 id="注意事项-2">注意事项</h3><ol><li>Map接口的常用实现类:HashMap、Hashtable和Properties。</li><li>HashMap是 Map 接口使用频率最高的实现类。</li><li>HashMap 是以key-val对的方式来存储数据(HashMap$Node类型)</li><li>key不能重复，但是值可以重复,允许使用null键和null值。</li><li>如果添加相同的key，则会覆盖原来的key-val ,等同于修改.(key不会替换，val会替换)</li><li>与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的. <code>(jdk8的hashMap底层数组+链表+红黑树)</code></li><li>HashMap没有实现同步，因此是线程不安全的,方法没有做同步互斥的操作,没有synchronized</li></ol><h3 id="底层机制及源码分析">底层机制及源码分析</h3><ol><li>HashMap底层维护了Node类型的数组table，默认为null</li><li>当创建对象时，将加载因子(Ioadfactor)初始化为<code>0.75</code></li><li>当添加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素,如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key相是否等,如果相等，则直接替换val;如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容。</li><li>第1次添加，则需要扩容table容量为16，临界值(threshold)为12 <code>(16*0.75)</code></li><li>以后再扩容，则需要扩容table容量为原来的2倍(32)，临界值为原来的2倍,即24,依次类推</li><li>在Java8中,如果一条链表的元素个数超过 TREEIFY_THRESHOLD(默认是8)，并且table的大小&gt;= MIN TREEIFY CAPACITY(默认64),就会进行树化<code>(红黑树)</code></li></ol><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/githubblog/article/202403202404301021154.png" alt=""></p><blockquote><p><em><strong>关于上图</strong></em></p><ol><li>（K,V）是一个node，实现了Map.Entry&lt;K,V&gt;</li><li>jdk7的HashMap底层实现<code>[数组+链表]</code>；jdk8底层实现<code>[数组+链表+红黑树]</code></li></ol></blockquote><h4 id="无参构造器-2">无参构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// 初始化加载因子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put方法">put方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="putVal方法">putVal方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,  </span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;  </span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;  </span><br><span class="line">     <span class="comment">//如果底层的table 数组为null, 或者 length =0 , 就扩容到16</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)  </span><br><span class="line">        n = (tab = resize()).length;  </span><br><span class="line">    <span class="comment">//取出hash值对应的table的索引位置的Node, 如果为null, 就直接把加入的k-v</span></span><br><span class="line">    <span class="comment">//创建成一个 Node ,加入该位置即可</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)  </span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);  </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;  <span class="comment">//辅助变量</span></span><br><span class="line">        <span class="comment">// 如果table的索引位置的key的hash相同和新的key的hash值相同，</span></span><br><span class="line">        <span class="comment">// 并 满足(table现有的结点的key和准备添加的key是同一个对象  || equals返回真)</span></span><br><span class="line">        <span class="comment">// 就认为不能加入新的k-v</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;  </span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">            e = p;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  <span class="comment">//如果当前的table的已有的Node 是红黑树，就按照红黑树的方式处理</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">//如果找到的结点，后面是链表，就循环比较</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;  <span class="comment">//死循环</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;  <span class="comment">//如果整个链表，没有和他相同,就加到该链表的最后</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//加入后，判断当前链表的个数，是否已经到8个，到8个，后</span></span><br><span class="line">                    <span class="comment">//就调用 treeifyBin 方法进行红黑树的转换  </span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;                <span class="keyword">if</span> (e.hash == hash &amp;&amp;  <span class="comment">//如果在循环比较过程中，发现有相同,就break,就只是替换value</span></span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                p = e;  </span><br><span class="line">            &#125;        &#125;        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;  </span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)  </span><br><span class="line">                e.value = value;  <span class="comment">//替换，key对应value</span></span><br><span class="line">            afterNodeAccess(e);  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    ++modCount;  <span class="comment">//每增加一个Node ,就size++</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)  <span class="comment">//如size &gt; 临界值，就扩容</span></span><br><span class="line">        resize();  </span><br><span class="line">    afterNodeInsertion(evict);  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="treeifyBin方法">treeifyBin方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于树化(转成红黑树)</span></span><br><span class="line"><span class="comment">//如果table 为null ,或者大小还没有到 64，暂时不树化，而是进行扩容.</span></span><br><span class="line"><span class="comment">//否则才会真正的树化 -&gt; 剪枝</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">     <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">     <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">       resize();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="并发替代方">并发替代方</h3><blockquote><p><em><strong>ConcurrentHashMap</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <summary type="html">汇总关于集合的有关内容及注意事项</summary>
    
    
    
    <category term="JAVA" scheme="https://www.zhen0w0.cn/categories/JAVA/"/>
    
    
    <category term="集合" scheme="https://www.zhen0w0.cn/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>JVM调优</title>
    <link href="https://www.zhen0w0.cn/posts/1653795f.html"/>
    <id>https://www.zhen0w0.cn/posts/1653795f.html</id>
    <published>2024-04-02T17:03:00.000Z</published>
    <updated>2024-04-02T17:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本原则">基本原则</h2><blockquote><p>JVM调优是一个手段，但并不一定所有问题都可以通过JVM进行调优解决；</p></blockquote><ul><li>大多数的Java应用不需要进行JVM优化；</li><li>大多数导致GC问题的原因是代码层面的问题导致的（代码层面）;</li><li>上线之前，应先考虑将机器的JVM参数设置到最优；</li><li>减少创建对象的数量（代码层面）；</li><li>减少使用全局变量和大对象（代码层面）；</li><li>优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）；</li><li>分析GC情况优化代码比优化JVM参数更好（代码层面）;</li></ul><h2 id="常见场景">常见场景</h2><ul><li><strong>Heap内存（老年代）持续上涨达到设置的最大内存值</strong></li><li><strong>Full GC 次数频繁；</strong></li><li><strong>GC 停顿时间过长（超过1秒）</strong></li><li><strong>应用出现OutOfMemory等内存异常</strong></li><li><strong>应用中有使用本地缓存且占用大量内存空间</strong></li><li><strong>系统吞吐量与响应性能不高或不降</strong></li></ul><h2 id="案例">案例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Xmx4g </span><br><span class="line">–Xms4g </span><br><span class="line">–Xmn1200m </span><br><span class="line">–Xss512k </span><br><span class="line">-XX:NewRatio=4 </span><br><span class="line">-XX:SurvivorRatio=8 </span><br><span class="line">-XX:PermSize=100m </span><br><span class="line">-XX:MaxPermSize=256m </span><br><span class="line">-XX:MaxTenuringThreshold=15</span><br></pre></td></tr></table></figure><h2 id="参数解析">参数解析</h2><blockquote><p>-Xms：<strong>初始化堆内存大小，默认为物理内存的1/64(小于1GB)。</strong><br>-Xmx：<strong>堆内存最大值，</strong> 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。<br>-Xmn：<strong>新生代大小，包括Eden区与2个Survivor区。</strong><br>-XX:SurvivorRatio=1：<strong>Eden区与一个Survivor区比值为1:1</strong>。<br>-XX:MaxDirectMemorySize=1G：<strong>直接内存。</strong> 报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。<br>-XX:+DisableExplicitGC：<strong>禁止运行期显式地调用System.gc()来触发fulll GC</strong><br>注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval=86400来控制触发的时间<br>-XX:CMSInitiatingOccupancyFraction=60：<strong>老年代内存回收阈值，默认值为68。</strong><br>-XX:ConcGCThreads=4：<strong>CMS垃圾回收器并行线程线，推荐值为CPU核心数。</strong><br>-XX:ParallelGCThreads=8：<strong>新生代并行收集器的线程数。</strong><br>-XX:MaxTenuringThreshold=10：<strong>设置垃圾最大年龄。</strong> 如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。<br>-XX:CMSFullGCsBeforeCompaction=4：<strong>指定进行多少次fullGC之后，进行tenured区 内存空间压缩。</strong><br>-XX:CMSMaxAbortablePrecleanTime=500：<strong>当abortable-preclean预清理阶段执行达到这个时间时就会结束。</strong></p></blockquote><h2 id="JVM参数使用手则">JVM参数使用手则</h2><h3 id="1-内存相关">1. 内存相关</h3><blockquote><p>通过这些参数可以对JVM的内存分配做调整</p></blockquote><p>Xms<br>英文解释：Initial heap size(in bytes)<br>中文释义：堆区初始值<br>使用方法：<code>-Xms2g 或 -XX:InitialHeapSize=2048m</code></p><p>Xmx<br>英文解释：Maximum heap size(in bytes)<br>中文释义：堆区最大值<br>使用方法：<code>-Xmx2g 或 -XX:MaxHeapSize=2048m</code></p><p>Xmn<br>英文解释：Maximum new generation size(in bytes)<br>中文释义：新生代最大值<br>使用方法：<code>-Xmn512m 或 -XX:MaxNewSize=512m</code></p><p>PermSize(JDK1.8以后已废弃)<br>英文解释：Initial size of permanent generation(in bytes)<br>中文释义：永久代初始大小<br>使用方法：<code>-XX:PermSize=128m</code></p><p>MaxPermSize(JDK1.8以后已废弃)<br>英文解释：Maximum size of permanent generation(in bytes)<br>中文释义：永久代最大值<br>使用方法：<code>-XX:MaxPermSize=256m</code></p><p>MetaspaceSize(JDK1.8以后用于替换PermSize)<br>英文解释：Initial size of Metaspaces (in bytes)<br>中文释义：元数据区初始大小<br>使用方法：<code>-XX:MetaspaceSize=128m</code></p><p>MaxMetaspaceSize(JDK1.8以后用于替换MaxPermSize)<br>英文解释：Maximum size of Metaspaces (in bytes)<br>中文释义：元数据区最大值<br>使用方法：<code>-XX:MaxMetaspaceSize=256m</code></p><p>Xss<br>英文解释：Thread Stack Size(in Kbytes)<br>中文释义：线程栈最大值<br>使用方法：<code>-Xss256k 或 -XX:ThreadStackSize=256k</code></p><p>MaxDirectMemorySize<br>英文解释：Maximum total size of NIO direct-buffer allocations<br>中文释义：最大直接内存（堆外）大小<br>使用方法：<code>-XX:MaxDirectMemorySize=256m</code></p><h3 id="2-GC策略相关">2. GC策略相关</h3><blockquote><p>通过这些参数可以对JVM的GC性能进行调优</p></blockquote><p>NewRatio<br>英文解释：Ratio of old/new generation sizes<br>中文释义：老年代和新生代的比值<br>使用方法：<code>-XX:NewRatio=2</code><br>使用经验：假如设为2，则表示老年代最大内存占堆最大内存的2/3，新生代则为1/3。如果设置了Xmn或者NewSize/MaxNewSize，那么NewRatio配置无效</p><p>SurvivorRatio<br>英文解释：Rato of eden/survivor space size<br>中文释义：新生代中eden区和survivor区的比值<br>使用方法：<code>-XX:SurvivorRatio=6</code><br>使用经验：假如设为6，则表示每个survivor区跟eden区的比值为1:6,每个survivor区占新生代的八分之一</p><p>PretenureSizeThreshold<br>英文解释：Maximum size in bytes of objects allocated in DefNew generation;zero means no maximum<br>中文释义：可以在新生代直接分配的对象最大值，0表示没有最大值<br>使用方法：<code>-XX:PretenureSizeThreshold=1000000</code><br>使用经验：设置该参数，可以使大于这个值的对象直接在老年代分配，避免在Eden区和Survivor区发生大量的内存复制，该参数只对Serial和ParNew收集器有效，Parallel Scavenge并不认识该参数</p><p>MaxTenuringThreshold<br>英文解释：Maximum value fo tenuring threshold<br>中文释义：年轻代最大年龄<br>使用方法：<code>-XX:MaxTenuringThreshold=10</code><br>使用经验：每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代，最大支持15</p><p>UseSerialGC<br>英文解释：Use the Serial garbage collector<br>中文释义：年轻代使用Serial垃圾收集器<br>使用方法：<br>开启 <code>-XX:+UseSerialGC</code><br>使用经验：不推荐使用，性能太差，老年代将会使用SerialOld垃圾收集器</p><p>UseParNewGC<br>英文解释：Use parallel threads in the new generation<br>中文释义：年轻代使用ParNew垃圾收集器<br>使用方法：<br>开启 <code>-XX:+UseParNewGC</code></p><p>ParallelGCThreads<br>英文解释：Number of parallel threads parallel gc will use<br>中文释义：并行执行gc的线程数<br>使用方法：<code>-XX:ParallelGCThreads=16</code></p><p>UseParallelGC<br>英文解释：Use the Parallel Scavenge garbage collector<br>中文释义：年轻代使用Parallel Scavenge垃圾收集器<br>使用方法：<br>开启 <code>-XX:+UseParallelGC</code><br>使用经验：Linux下1.6,1.7,1.8默认开启，老年代将会使用SerialOld垃圾收集器</p><p>UseParallelOldGC<br>英文解释：Use the Parallel Old garbage collector<br>中文释义：年轻代使用Parallel Scavenge收集器<br>使用方法：<br>开启 <code>-XX:+UseParallelOldGC</code><br>使用经验：老年代将会使用Parallel Old收集器</p><p>UseConcMarkSweepGC<br>英文解释：Use Concurrent Mark-Sweep GC in the old generation<br>中文释义：老年代使用CMS收集器（如果出现&quot;Concurrent Mode Failure&quot;，会使用SerialOld收集器）<br>使用方法：<br>开启 <code>-XX:+UseConcMarkSweepGC</code><br>使用经验：年轻代将会使用ParNew收集器</p><p>CMSInitiatingOccupancyFraction<br>英文解释：Percentage CMS generation occupancy to start a CMS collection cycle. A negative value means that CMSTriggerRatio is used<br>中文释义：触发执行CMS回收的当前年代区内存占用的百分比，负值表示使用CMSTriggerRatio设置的值<br>使用方法：<code>-XX:CMSInitiatingOccupancyFraction=75</code><br>使用经验：该参数需配合UseCMSInitiatingOccupancyOnly一起使用</p><p>UseCMSInitiatingOccupancyOnly<br>英文解释：Only use occupancy as a criterion for staring a CMS collection<br>中文释义：只根据占用情况作为开始执行CMS收集的标准，默认关闭<br>使用方法：<br>开启 <code>-XX:+UseCMSInitiatingOccupancyOnly</code></p><p>UseCMSCompactAtFullCollection<br>英文解释：Use Mark-Sweep-Compact algorithm at full collections<br>中文释义：使用CMS执行Full GC时对内存进行压缩，默认关闭<br>使用方法：<br>开启 <code>-XX:+UseCMSCompactAtFullCollection</code></p><p>CMSFullGCsBeforeCompaction<br>英文解释：Number of CMS full collection done before compaction if &gt; 0<br>中文释义：多少次FGC后进行内存压缩<br>使用方法：<code>-XX:CMSFullGCsBeforeCompaction=1</code></p><p>CMSClassUnloadingEnabled<br>英文解释：Whether class unloading enabled when using CMS GC<br>中文释义：当使用CMS GC时是否启用类卸载功能，默认关闭<br>使用方法：<br>开启 <code>-XX:+CMSClassUnloadingEnabled</code></p><p>CMSParallelRemarkEnabled<br>英文解释：Whether parallel remark enabled (only if ParNewGC)<br>中文释义：是否启用并行标记（仅限于ParNewGC），默认关闭<br>使用方法：<br>开启 <code>-XX:+CMSParallelRemarkEnabled</code></p><p>UseG1GC<br>英文解释：Use the Garbage-First garbage collector<br>中文释义：使用G1垃圾收集器<br>使用方法：<br>开启 <code>-XX:+UseG1GC</code></p><p>MaxGCPauseMillis<br>英文解释：Adaptive size policy maximum GC pause time goal in millisecond, or (G1 Only) the maximum GC time per MMU time slice<br>中文释义：自适应大小策略的最大GC暂停时间目标（以毫秒为单位），或（仅G1）每个MMU时间片的最大GC时间<br>使用方法：<code>-XX:MaxGCPauseMillis=200</code></p><p>DisableExplicitGC<br>英文解释：Ignore calls to System.gc()<br>中文释义：禁用System.gc()触发FullGC<br>使用方法：<br>开启 <code>-XX:+DisableExplicitGC</code><br>PS:不建议开启，如果开启了这个参数可能会导致堆外内存无法及时回收造成内存溢出</p><h3 id="3-GC日志相关">3. GC日志相关</h3><blockquote><p>通过这些参数可以对JVM的GC日志输出进行配置，方便分析</p></blockquote><p>Xloggc<br>英文解释：GC log file<br>中文释义：GC日志文件路径<br>使用方法：<code>-Xloggc:/data/gclog/gc.log</code></p><p>UseGCLogFileRotation<br>英文解释：Rotate gclog files(for long running applications). It requires -Xloggc:<filename><br>中文释义：滚动GC日志文件，须配置Xloggc<br>使用方法：<br>开启 <code>-XX:+UseGCLogFileRotation</code></p><p>NumberOfGCLogFiles<br>英文解释：Number of gclog files in rotation(default:0,no rotation)<br>中文释义：滚动GC日志文件数，默认0，不滚动<br>使用方法：<code>-XX:NumberOfGCLogFiles=4</code></p><p>GCLogFileSize<br>英文解释：GC log file size,requires UseGCLogFileRotation. Set to 0 to only trigger rotation via jcmd<br>中文释义：GC文件滚动大小，需配置UseGCLogFileRotation，设置为0表示仅通过jcmd命令触发<br>使用方法：<code>-XX:GCLogFileSize=100k</code></p><p>PrintGCDetails<br>英文解释：Print more details at garbage collection<br>中文释义：GC时打印更多详细信息，默认关闭<br>使用方法：<br>开启 <code>-XX:+PrintGCDetails</code><br>可以通过jinfo -flag [+|-]PrintGCDetails <pid> 或 jinfo -flag PrintGCDetails=<value> <pid> 来动态开启或设置值</p><p>PrintGCDateStamps<br>英文解释：Print date stamps at garbage collection<br>中文释义：GC时打印时间戳信息，默认关闭<br>使用方法：<br>开启 <code>-XX:+PrintGCDateStamps</code><br>可以通过jinfo -flag [+|-]PrintGCDateStamps <pid> 或 jinfo -flag PrintGCDateStamps=<value> <pid> 来动态开启或设置值</p><p>PrintTenuringDistribution<br>英文解释：Print tenuring age information<br>中文释义：打印存活实例年龄信息，默认关闭<br>使用方法：<br>开启 <code>-XX:+PrintTenuringDistribution</code></p><p>PrintGCApplicationStoppedTime<br>英文解释：Print the time of application has been stopped<br>中文释义：打印应用暂停时间，默认关闭<br>使用方法：<br>开启<code> -XX:+PrintGCApplicationStoppedTime</code></p><p>PrintHeapAtGC<br>英文解释：Print heap layout before and after each GC<br>中文释义：GC前后打印堆区使用信息，默认关闭<br>使用方法：<br>开启 <code>-XX:+PrintHeapAtGC</code></p><h3 id="4-异常相关">4. 异常相关</h3><blockquote><p>通过这些参数可以在JVM异常情况下执行某些操作，以保留现场做分析用</p></blockquote><p>HeapDumpOnOutOfMemoryError<br>英文解释：Dump heap to file when java.lang.OutOfMemoryError is thrown<br>中文释义：抛出内存溢出错误时导出堆信息到指定文件，默认关闭<br>使用方法：<br>开启 <code>-XX:+HeapDumpOnOutOfMemoryError</code><br>可以通过jinfo -flag [+|-]HeapDumpOnOutOfMemoryError <pid> 或 jinfo -flag HeapDumpOnOutOfMemoryError=<value> <pid> 来动态开启或设置值</p><p>HeapDumpPath<br>英文解释：When HeapDumpOnOutOfMemoryError is on, the path(filename or directory) of the dump file(defaults to java_pid<pid>.hprof in the working directory)<br>中文释义：当HeapDumpOnOutOfMemoryError开启的时候，dump文件的保存路径，默认为工作目录下的java_pid<pid>.hprof文件<br>使用方法：<code>-XX:HeapDumpPath=/data/dump/jvm.dump</code><br>使用经验：除非必要，建议不设置</p><p>OmitStackTraceInFastThrow<br>英文解释：Omit backtraces for some ‘hot’ exceptions in optimized code<br>中文释义：在优化代码里面忽略热点异常回溯<br>使用方法：<br>关闭 <code>-XX:-OmitStackTraceInFastThrow</code><br>使用经验：某些热点异常抛的太多的话，JVM默认会做优化，会使用JVM初始化的时候创建的异常代替实际的异常，这些异常是没有异常栈信息的，不方便定位问题，如果有碰到这种情况，可以考虑关闭这个配置</p><h3 id="5-问题定位及优化相关">5. 问题定位及优化相关</h3><blockquote><p>通过这些参数可以对JVM进行性能优化或者排查定位问题</p></blockquote><p>server<br>英文解释：server mode<br>中文释义：使用服务端模式<br>使用方法：<code>-server</code></p><p>TieredCompilation<br>英文解释：Enable tiered compilation<br>中文释义：启用多层编译<br>使用方法：<br>开启 <code>-XX:+TieredCompilation</code><br>关闭<code> -XX:-TieredCompilation</code><br>使用经验：java 1.8默认开启分层编译，该参数无效</p><p>NativeMemoryTracking<br>英文解释：Native memory tracking options<br>中文释义：开启本机内存追踪<br>使用方法：<br>开启详细信息 <code>-XX:NativeMemoryTracking=detail</code><br>开启概要信息 <code>-XX:NativeMemoryTracking=summary</code><br>使用经验：开启的话，大概会增加5%-10%的性能消耗</p><p>UnlockDiagnosticVMOptions<br>英文解释：Enable normal processing of flags<br>中文释义：解锁对JVM进行诊断的选项参数，默认关闭<br>使用方法：<br>开启 <code>-XX:+UnlockDiagnosticVMOptions</code></p><p>PrintNMTStatistics<br>英文解释：Print native memory tracking summary data if it is on<br>中文释义：在jvm shutdown的时候输出整体的native memory统计，默认关闭<br>使用方法：<br>开启 <code>-XX:+PrintNMTStatistics</code><br>使用经验：必须配合参数-XX:+UnlockDiagnosticVMOptions使用，并且只能加在其后才能生效</p><p>UseAdaptiveSizePolicy<br>英文解释：Use adaptive generation sizing policies<br>中文释义：使用自适应分代内存策略<br>使用方法：<br>开启 <code>-XX:+UseAdaptiveSizePolicy</code><br>关闭 <code>-XX:-UseAdaptiveSizePolicy</code><br>使用经验：1.7以后默认会开启该参数，如果使用CMS回收算法，则会关闭该参数，该参数开启以后会使SurvivorRatio参数失效，如果显示指定了SurvivorRatio，需要关闭该参数</p><h2 id="常见参数">常见参数</h2><table><thead><tr><th>参数</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小，默认物理内存的1/64</td><td>-Xms512M</td></tr><tr><td>-Xmx</td><td>最大堆大小，默认物理内存的1/4</td><td>-Xms2G</td></tr><tr><td>-Xmn</td><td>新生代内存大小，官方推荐为整个堆的3/8</td><td>-Xmn512M</td></tr><tr><td>-Xss</td><td>线程堆栈大小，jdk1.5及之后默认1M，之前默认256k</td><td>-Xss512k</td></tr><tr><td>-XX:NewRatio=n</td><td>设置新生代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</td><td>-XX:NewRatio=3</td></tr><tr><td>-XX:SurvivorRatio=n</td><td>年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如:8，表示Eden：Survivor=8:1:1，一个Survivor区占整个年轻代的1/8</td><td>-XX:SurvivorRatio=8</td></tr><tr><td>-XX:PermSize=n</td><td>永久代初始值，默认为物理内存的1/64</td><td>-XX:PermSize=128M</td></tr><tr><td>-XX:MaxPermSize=n</td><td>永久代最大值，默认为物理内存的1/4</td><td>-XX:MaxPermSize=256M</td></tr><tr><td>-verbose:class</td><td>在控制台打印类加载信息</td><td></td></tr><tr><td>-verbose:gc</td><td>在控制台打印垃圾回收日志</td><td></td></tr><tr><td>-XX:+PrintGC</td><td>打印GC日志，内容简单</td><td></td></tr><tr><td>-XX:+PrintGCDetails</td><td>打印GC日志，内容详细</td><td></td></tr><tr><td>-XX:+PrintGCDateStamps</td><td>在GC日志中添加时间戳</td><td></td></tr><tr><td>-Xloggc:filename</td><td>指定gc日志路径</td><td>-Xloggc:/data/jvm/gc.log</td></tr><tr><td>-XX:+UseSerialGC</td><td>年轻代设置串行收集器Serial</td><td></td></tr><tr><td>-XX:+UseParallelGC</td><td>年轻代设置并行收集器Parallel Scavenge</td><td></td></tr><tr><td>-XX:ParallelGCThreads=n</td><td>设置Parallel Scavenge收集时使用的CPU数。并行收集线程数。</td><td>-XX:ParallelGCThreads=4</td></tr><tr><td>-XX:MaxGCPauseMillis=n</td><td>设置Parallel Scavenge回收的最大时间(毫秒)</td><td>-XX:MaxGCPauseMillis=100</td></tr><tr><td>-XX:GCTimeRatio=n</td><td>设置Parallel Scavenge垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</td><td>-XX:GCTimeRatio=19</td></tr><tr><td>-XX:+UseParallelOldGC</td><td>设置老年代为并行收集器ParallelOld收集器</td><td></td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>设置老年代并发收集器CMS</td><td></td></tr><tr><td>-XX:+CMSIncrementalMode</td><td>设置CMS收集器为增量模式，适用于单CPU情况。</td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">汇总关于JVM调优的有关内容</summary>
    
    
    
    <category term="JVM" scheme="https://www.zhen0w0.cn/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://www.zhen0w0.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>AQS梳理（重制版）</title>
    <link href="https://www.zhen0w0.cn/posts/b1d7b80d.html"/>
    <id>https://www.zhen0w0.cn/posts/b1d7b80d.html</id>
    <published>2024-03-31T17:54:00.000Z</published>
    <updated>2024-03-31T17:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="释义">释义</h2><blockquote><p>AQS----AbstractQueuedSynchronizer----抽象的队列同步器</p><p><strong>volatile+cas机制实现的锁模板，保证了代码的同步性和可见性，而AQS封装了线程阻塞等待挂起，解锁唤醒其他线程的逻辑。AQS子类只需根据状态变量，判断是否可获取锁，是否释放锁，使用LockSupport挂起、唤醒线程即可</strong></p></blockquote><h2 id="AQS体系架构">AQS体系架构</h2><p><strong>蓝色：继承；红色：内部；绿色：实现</strong><br><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/githubblog/article/202403202404181648743.png" alt=""></p><h3 id="AQS抽象类简介">AQS抽象类简介</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span>  </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span>  </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984972572414691L</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractQueuedSynchronizer</span><span class="params">()</span> &#123; &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;...&#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> state;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ..........</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>Node：</strong></em> 将抢占资源的线程封装为node节点<br><em><strong>head&amp;tail：</strong></em> 双向CLH队列的头尾<br><strong>state：</strong> 状态标识（0空闲，1繁忙）</p></blockquote><h3 id="Node类waitStatus分析">Node类waitStatus分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为1的时候说明这个任务可能因为中断或者其他原因取消了  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;  </span><br><span class="line"><span class="comment">// 代表下一个节点需要被唤醒  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line"><span class="comment">// 用于条件队列,等待condition唤醒</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;  </span><br><span class="line"><span class="comment">// 用于共享锁，共享式同步状态取消，将会无条件传播下去</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="双向CLH队列">双向CLH队列</h3><blockquote><p><em><strong>AQS本质就是 <code>state变量+CLH双端Node队列</code></strong></em></p></blockquote><blockquote><p>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是<em><strong>CLH队列</strong></em>的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS同步队列的抽象表现。它将要请求共享资源的线程及自身的等待状态封装成队列的结点对象(Node)，通过<code>CAS自旋</code>以及<code>LockSupport.park()</code>的方式，维护<code>state变量</code>的状态，使并发达到同步的效果。</p></blockquote><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/githubblog/article/202403202404191131156.png" alt=""></p><h2 id="AQS源码解读">AQS源码解读</h2><h3 id="公平锁-非公平锁">公平锁&amp;非公平锁</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">公平锁</button></li><li class="tab"><button type="button" data-href="#分栏-2">非公平锁</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;  </span><br><span class="line">        acquire(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();  </span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();  </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;  </span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;  </span><br><span class="line">                setExclusiveOwnerThread(current);  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;  </span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);  </span><br><span class="line">            setState(nextc);  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))  </span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            acquire(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);  </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="非公平锁分析">非公平锁分析</h3><h4 id="lock方法">lock方法</h4><blockquote><p>通过cas将状态<code>status</code>由0变为1<br>如果成功的话，将当前线程设置为有访问权限线程<br>如果cas失败的话会进入else语句执行acquire(1)<code>抢占失败</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))  </span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        acquire(<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="acquire方法">acquire方法</h4><blockquote><ul><li>调用tryAcquire()：尝试获得锁，或执行可重入操作</li><li>调用addWaiter() --&gt; enq入队操作：队列内无节点则创建哨兵节点后入队，有节点则直接入队</li><li>调用acquireQueued() --&gt; 调用cancelAcquire()：再次尝试1 tryAcquire()，如果失败则修改它的前一个节点的waitState为SIGNAL（-1）后进入阻塞，等待被唤醒</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;  </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  </span><br><span class="line">        selfInterrupt();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="tryAcquire方法">tryAcquire方法</h5><blockquote><p><code>ReentrantLock</code>中的<code>NonfairSync</code>重写了<code>tryAcquire</code>方法，内部调用了<code>nonfairTryAcquire</code>方法</p><ul><li>先获得当前状态state，如果state=0，则自旋修改state为1，并修改占有锁的线程为当前线程，返回true，acquire()方法结束</li><li>else if 判断当前占有锁的线程是否为当前线程，如果是，则将state+1并返回true，acquire()方法结束<code>锁被重入</code></li><li>在重入过程中, 如果资源数量由正变负, 代表资源溢出了, 毕竟初始值是0, 获取资源时也是不断累加, 不会有人尝试获取负数的资源, 那没有意义. 我们都知道int类型的数据取值范围是<code>[ -2147483648, 2147483647]</code> 所以一般不会触发这个Error</li><li>前面两个条件都不满足，则tryAcquire()方法失败，返回false</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();  </span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();  </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;  </span><br><span class="line">            setExclusiveOwnerThread(current);  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;  </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);  </span><br><span class="line">        setState(nextc);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="addWaiter-Node-EXCLUSIVE">addWaiter(Node.EXCLUSIVE)</h5><blockquote><p><code>addWaiter</code>方法是给当前线程创建一个节点, 并添加到同步队列中, 排队等待机会获取锁, 参数Node.EXCLUSIVE代表当前线程希望以独占模式获取锁</p><p>然后获得尾节点, 如果尾节点已经创建，则使用尾插法将节点入队, 如果没有则调用enq方法入队, 实际上enq就是<code>多了一步初始化头节点和尾节点的处理</code>, 入队依然是使用相同的尾插法</p><p>在<code>理想状态</code>下首先同样会拿到当前队列的尾节点然后判断是否为null，如果为null的话说明此时还不存在尾节点，则创建一个节点当队列的头节点，里边的数据是null，然后cas的方式将其设为头节点然后尾节点也是它，因为我们这个分支里边并没有return语句所以还会重新进入循环，此时尾节点已经不是null了，那么我们进入else里边的分支，首先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;node.prev = t;  </span><br><span class="line"><span class="comment">// 这句话会将当前节点的上一个节点设为头节点，然后通过cas的方式去将当前的节点设置为队列的尾节点  </span></span><br><span class="line"><span class="comment">// 如果设置成功的话将当前队列的尾节点的下一个节点设置成当前节点然后将其返回</span></span><br></pre></td></tr></table></figure><p>在<code>不理想状态</code>的时候，模拟一下场景, 假如线程A进入了for循环, 判断了当前的尾节点为null，但是他在执行compareAndSetHead(new Node())的时候, 刚new出自己的节点来之后，就被线程B抢先将队列的头节点设置为自己new的节点，此时队列的尾节点就是线程B的节点数据，那么此时线程A去cas设置头节点就会失败，然后线程A进入下一轮循环, 此时的尾节点已经存在，我们就会使用尾插法将线程A设置为新的尾节点，最终返回旧的尾节点(这是因为AQS是前驱节点负责唤醒当前节点)</p></blockquote><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">```java</span><br><span class="line">//加入等待线程的方法 </span><br><span class="line">//参数Node.EXCLUSIVE的意思是独占锁，另一种锁位Node.SHARED共享锁</span><br><span class="line">private <span class="keyword">Node</span> <span class="title">addWaiter</span>(<span class="keyword">Node</span> <span class="title">mode</span>) &#123;  </span><br><span class="line">    //先new一个新的节点用来装当前线程，模式为独占模式</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = new <span class="keyword">Node</span><span class="title">(Thread</span>.currentThread(), mode); </span><br><span class="line">    //定义一个节点pred为当前队列的尾节点 </span><br><span class="line">    <span class="keyword">Node</span> <span class="title">pred</span> = tail;</span><br><span class="line">    //不为null，说明不是第一个要进入等待队列的线程，第一个线程为null直接跳过执行下面的enq(<span class="keyword">node</span><span class="title">)</span></span><br><span class="line"><span class="title">    if</span> (pred != null) &#123;  </span><br><span class="line">        node.prev = pred;  </span><br><span class="line">        if (compareAndSetTail(pred, <span class="keyword">node</span><span class="title">)) &#123;  </span></span><br><span class="line"><span class="title">            pred</span>.next = <span class="keyword">node</span><span class="title">;  </span></span><br><span class="line"><span class="title">            return</span> <span class="keyword">node</span><span class="title">;  </span></span><br><span class="line"><span class="title">        &#125;    </span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">    //队列中无节点才会执行enq</span>()方法    </span><br><span class="line">    enq(<span class="keyword">node</span><span class="title">);  </span></span><br><span class="line"><span class="title">    return</span> <span class="keyword">node</span><span class="title">;  </span></span><br><span class="line"><span class="title">&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">private</span> <span class="keyword">Node</span> <span class="title">enq</span>(final <span class="keyword">Node</span> <span class="title">node</span>) &#123;  </span><br><span class="line">    for (;;) &#123;  </span><br><span class="line">        <span class="keyword">Node</span> <span class="title">t</span> = tail;  </span><br><span class="line">        if (t == null) &#123; //第一次入队时尾节点t为空</span><br><span class="line">            if (compareAndSetHead(new <span class="keyword">Node</span><span class="title">()))  </span></span><br><span class="line"><span class="title">                tail</span> = head;  </span><br><span class="line">        &#125; else &#123;  //不是第一次入队，尾节点t不为空</span><br><span class="line">            node.prev = t;  </span><br><span class="line">            if (compareAndSetTail(t, <span class="keyword">node</span><span class="title">)) &#123;  //将当前线程的节点的前置节点设为之前的尾节点</span></span><br><span class="line"><span class="title">                t</span>.next = <span class="keyword">node</span><span class="title">; //设置之前的尾节点t</span>的下一个节点为当前线程的节点<span class="keyword">node</span> </span><br><span class="line">                <span class="title">return</span> t;  </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>enq()方法会返回旧的尾节点，但是addWaiter是返回当前线程的节点</code></p></blockquote><h5 id="acquireQueued方法">acquireQueued方法</h5><blockquote><p>上一个方法将当前线程的节点添加到同步队列之后, 会将其前驱节点返回, acquireQueued方法会尝试将该前驱节点设置为新的头节点, 以此来唤醒当前线程的节点</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;  </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 在获取锁的过程中是否获取失败 </span></span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;  <span class="comment">// 在获取锁的过程中是否发生了中断</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">//该方法为设置前置节点  </span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;  </span><br><span class="line">                setHead(node);  </span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC  </span></span><br><span class="line">                failed = <span class="literal">false</span>;  </span><br><span class="line">                <span class="keyword">return</span> interrupted;  </span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  </span><br><span class="line">                parkAndCheckInterrupt())  </span><br><span class="line">                interrupted = <span class="literal">true</span>;  </span><br><span class="line">          &#125;    </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (failed)  </span><br><span class="line">            cancelAcquire(node);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>for循环逻辑</strong></em></p><ol><li>拿到当前节点的前置节点,如果前置节点是头节点的话, 代表当前节点已经是队列中第一个待执行的节点, 此时可以再次尝试获取锁,无需任何等待<code>(这里再次尝试获得锁的原因是，可能在添加节点到队列的过程中，拥有当前锁线程已经被释放)</code></li><li>我们先看获取锁成功的时候，如果获取锁成功的话我们就会将当前的节点设置为头节点</li></ol> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">   <span class="comment">// 首先将我们的当前节点设为头节点</span></span><br><span class="line">    head = node;</span><br><span class="line">    <span class="comment">// 然后将当前节点的线程数据置为null</span></span><br><span class="line">     node.thread = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 将当前节点的前驱节点置为null</span></span><br><span class="line">    node.prev = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>接下来将前驱节点的后继节点设为null，因为上一步已经将当前节点的前置节点设为了null所以现在已经不需要之前的头节点了，所以我们需要将原始头节点的的后继节点设为null，此时头节点就没有任何的引用了，<code>GC会将他进行回收</code></li><li>然后将是否获取失败标志位设为false，然后返回false</li><li>如果当前节点不是头节点或者是头节点但是抢占锁失败的情况下是如何处理，即以下部分代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  </span><br><span class="line">           parkAndCheckInterrupt())  </span><br><span class="line">           interrupted = <span class="literal">true</span>;  </span><br></pre></td></tr></table></figure><blockquote><ol><li>shouldParkAfterFailedAcquire(p, node)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;  </span><br><span class="line">   <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;  <span class="comment">//获取前驱节点（即当前线程的前一个节点）的等待状态</span></span><br><span class="line">   <span class="keyword">if</span> (ws == Node.SIGNAL)  <span class="comment">//如果前驱节点的等待状态是SIGNAL，表示当前节点将来可以被唤醒，那么当前节点就可以安全的挂起了</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1）当ws&gt;0(即CANCELLED == 1），前驱节点的线程被取消了，我们会将该节点之前的连续几个被取消的前驱节点从队列中剔除，返回false（即不能挂起）</span></span><br><span class="line"><span class="comment">* 2）如果ws&lt;=0&amp;&amp;!=SIGNAL,将当前节点的前驱节点的等待状态设为SIGNAL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">       <span class="comment">// 这里我在下边没有讲到这里就是如果大于0就说明这个任务可能因为中断或者其他原因取消了，我们就将当前的节点的前驱节点置为前驱节点的前驱，其实目的就是跳过有问题的节点，找到我们上一个可以唤醒下一节点的节点  </span></span><br><span class="line">        <span class="keyword">do</span> &#123;  </span><br><span class="line">           node.prev = pred = pred.prev;  </span><br><span class="line">       &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);  </span><br><span class="line">       pred.next = node;  </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 尝试将当前节点的前驱节点的等待状态设为SIGNAL</span></span><br><span class="line"><span class="comment">    * 1/这为什么用CAS，现在已经入队成功了，前驱节点就是pred，除了node外应该没有别的线程在操作这个节点了，那为什么还要用CAS？而不直接赋值呢？</span></span><br><span class="line"><span class="comment">    * （解释：因为pred可以自己将自己的状态改为cancel，也就是pred的状态可能同时会有两条线程（pred和node）去操作）</span></span><br><span class="line"><span class="comment">    * 2/既然前驱节点已经设为SIGNAL了，为什么最后还要返回false</span></span><br><span class="line"><span class="comment">    * （因为CAS可能会失败，这里不管失败与否，都返回false，下一次执行该方法的之后，pred的等待状态就是SIGNAL了）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">       compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">  &gt;&#125;</span><br></pre></td></tr></table></figure><p>这个方法呢他的作用就是检查并重新获取失败节点的状态，waitStatus只可能为-1，1，还有初始值0，注意有两个参数，参数一是<code>前驱节点</code>，参数二是<code>当前的节点</code>，当队列中添加了节点之后int ws = pred.waitStatus;获得前驱节点默认值肯定是0，然后进来进行判断走进else语句中执行compareAndSetWaitStatus(pred, ws, Node.SIGNAL);将前驱节点的状态值改为Node.SIGNAL，也就是-1，然后返回false此时就不去执行parkAndCheckInterrupt()方法了，而是重新进入for循环，此时如果还满足第一个if的条件的话，进入第二次循环中, 如果再次进入shouldParkAfterFailedAcquire, 此时前驱节点的等待状态就是Node.SIGNAL, 所以直接返回true, 并执行parkAndCheckInterrupt(), 将当前线程挂起</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="name">shouldParkAfterFailedAcquire</span>(<span class="name">p</span>, node) <span class="symbol">&amp;&amp;</span>  parkAndCheckInterrupt())</span><br></pre></td></tr></table></figure><ol start="2"><li>此时在进入shouldParkAfterFailedAcquire(p, node)之后前驱节点的标志位就是-1<code>（节点需要被唤醒）</code>了，进入parkAndCheckInterrupt()方法中</li></ol> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;  </span><br><span class="line">   LockSupport.park(<span class="built_in">this</span>);  <span class="comment">//挂起当前的线程</span></span><br><span class="line">   <span class="keyword">return</span> Thread.interrupted();  <span class="comment">//如果当前线程已经被中断了，返回true</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个方法就是将当前的线程挂起</p></blockquote></blockquote><h6 id="ancelAcquire-node">ancelAcquire(node)</h6><blockquote><p>ancelAcquire(node);在非公平锁独占模式下发生的概率很小，进入条件为当前线程节点，在完成循环等待与抢夺锁资源后，仍然失败，<code>failer为true</code></p><p>方法的作用是在当前节点再次获取锁失败后，判断当前线程是否需要挂起等待, 此时, 当前节点确实是队列中下一个执行的节点, 但是前面的节点还没释放锁, 所以当前线程可能需要挂起自己, 等待唤醒, 该方法返回true则挂起当前线程, false则返回acquireQueued方法继续自旋.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">  </span><br><span class="line">    node.thread = <span class="literal">null</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;  </span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)  </span><br><span class="line">        node.prev = pred = pred.prev;  </span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;  </span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="literal">null</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;  </span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||  </span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;  </span><br><span class="line">            pred.thread != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;  </span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)  </span><br><span class="line">                compareAndSetNext(pred, predNext, next);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            unparkSuccessor(node);  </span><br><span class="line">        &#125;  </span><br><span class="line">        node.next = node; <span class="comment">// help GC  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>先判断当前节点是否为null，如果是直接return</li><li>当前节点的关联线程设置为null，然后获取当前节点的前驱节点</li><li>通过while循环将waitStatus的值大于0的过滤掉也就是跳过有问题的节点，找到我们上一个可以唤醒下一节点的节点。并且把当前的节点状态设置为Node.CANCELLED;此时出现if语句根据不同情况进行不同的处理</li><li>如果当前节点是尾节点的话，将从后往前找，找到第一个状态为非取消状态的节点设置为尾节点<ul><li>如果设置成功的话将当前尾节点的后继节点设为null</li><li>如果设置失败的话将进入else语句</li></ul></li><li>如果当前节点不是尾节点的话也进入eles语句 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pred != head <span class="comment">//如果当前节点不是头节点的后继节点</span></span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 判断当前节点的前驱节点状态是不是SIGNAL ，如果不是的话则把前驱节点设置为SIGNAL 看看是否成功</span></span><br><span class="line">((ws = pred.waitStatus) == Node.SIGNAL ||  (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL)))</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pred.thread != <span class="literal">null</span> <span class="comment">//判断当前节点的线程是否为null</span></span><br></pre></td></tr></table></figure><blockquote><p>如果上述条件都满足则把当前节点的前驱节点的后继指针指向当前节点的后继节点<br>如果上述条件都不满足的话也就是当前节点是头节点的后继节点或者不满足上边的条件那就调用unparkSuccessor(node);<code>唤醒下一个需要获取锁的节点</code></p></blockquote></li></ol></blockquote><h4 id="unlock方法">unlock方法</h4><blockquote><p>ReentrantLock中的解锁并没有区分公平锁和非公平锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;  </span><br><span class="line">    sync.release(<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;  </span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;  <span class="comment">//如果成功释放锁</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;  <span class="comment">//获取头节点：（注意：这里的头节点就是当前正在释放锁的节点）</span></span><br><span class="line"><span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)  <span class="comment">//头结点存在且等待状态，不是取消</span></span><br><span class="line">unparkSuccessor(h);  <span class="comment">//唤醒距离头节点最近的一个非取消的节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>h != null &amp;&amp; h.waitStatus != 0</code></p><ol><li>h == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。</li><li>h != null &amp;&amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。</li><li>h != null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</li></ol></blockquote><pre><code>##### tryRelease方法</code></pre><blockquote><p>ReentrantLock加锁过程中支持可重入锁，首先会减去可重入的次数，然后判断一下当前持有锁的线程是不是当前线程如果不是的话直接抛出IllegalMonitorStateException();异常</p><ol><li>接下来定义一个free，如果tryRelease将当前持有的线程全部释放掉的话则返回true，否则返回false</li><li>如果已经全部释放掉了做一下处理将free设置为true然后设置当前的锁没有线程拥有它然后返回true</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;  <span class="comment">//获取现在的锁数量-传入的解锁数量（这里为1）</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())  <span class="comment">//当前线程不持有锁</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();  </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  <span class="comment">//锁被释放</span></span><br><span class="line">        free = <span class="literal">true</span>;  </span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    setState(c);  </span><br><span class="line">    <span class="keyword">return</span> free;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>回到release()方法，如果此时的tryRelease(arg)返回了ture说明了该锁没有被任何线程持有然后我们可以进行if语句里边的操作</p></blockquote><h5 id="unparkSuccessor方法">unparkSuccessor方法</h5><blockquote><p>进入方法后获取当前节点状态，如果小于0则设置为0，也就是初始状态<br>然后获取当前节点的下一个节点</p><p>if语句的意思就是如果当前节点的下一个节点被 <em>cancelled（中断）</em> 掉了就找到队列最开始的非 <em>cancelled</em> 的节点，但是里边的for循环是从队列的尾部开始找的，而不是从一开始就找，是从队尾到队首拿到队列的第一个 <em>waitStatus&lt;0</em> 的节点</p><p>节点入队列的操作并不是原子的，所以不排除有这种情况在入队过程中执行到了pred.next = node的时候，此时还没有执行这条代码，但是这时候调用了unparkSuccessor，到达这里的时候就没有办法从前往后找了因为这里相当于链表的断链了所以需要从后往前找</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;  </span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)  <span class="comment">//将ws设为0状态（即什么状态都不是）</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;  </span><br><span class="line">    <span class="comment">//获取头节点的下一个等待状态不是cancel的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        s = <span class="literal">null</span>;  </span><br><span class="line">        <span class="comment">//注意：从后往前遍历找到离头节点最近的一个非取消的节点，从后往前遍历据说是在入队（enq()）的时候，可能nodeX.next==null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)  </span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)  </span><br><span class="line">                s = t;  </span><br><span class="line">    &#125;   </span><br><span class="line">     <span class="keyword">if</span> (s != <span class="literal">null</span>)  </span><br><span class="line">        <span class="comment">//唤醒离头节点最近的一个非取消的节点</span></span><br><span class="line">        LockSupport.unpark(s.thread);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><em><strong>唤醒后：</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;  </span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);  </span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();  <span class="comment">//返回当前执行线程的中断状态，并清除</span></span><br></pre></td></tr></table></figure><p>然后回到acquireQueued()方法中</p></blockquote>]]></content>
    
    
    <summary type="html">关于AQS内容整理与补充</summary>
    
    
    
    <category term="Spring" scheme="https://www.zhen0w0.cn/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://www.zhen0w0.cn/tags/Spring/"/>
    
    <category term="注解" scheme="https://www.zhen0w0.cn/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>@Async注解详解</title>
    <link href="https://www.zhen0w0.cn/posts/90eac9a4.html"/>
    <id>https://www.zhen0w0.cn/posts/90eac9a4.html</id>
    <published>2024-03-29T09:24:00.000Z</published>
    <updated>2024-03-29T09:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><blockquote><p>Spring中用@Async注解标记的方法，称为异步方法，它会在调用方的当前线程之外的独立的线程中执行</p></blockquote><p><strong>@Async注解使用条件：</strong><br>1.  @Async注解一般用在类的方法上，如果用在类上，那么这个类所有的方法都是异步执行的；<br>2.  所使用的@Async注解方法的类对象应该是Spring容器管理的bean对象；<br>3.  调用异步方法类上需要配置上注解@EnableAsync<br><strong>注意事项：</strong><br>1. 默认情况下（即@EnableAsync注解的mode=AdviceMode.PROXY），同一个类内部没有使用@Async注解修饰的方法或调用@Async注解修饰的方法，是不会异步执行的，这点跟 @Transitional 注解类似，底层都是通过动态代理实现的。如果想实现类内部自调用也可以异步，则需要切换@EnableAsync注解的mode=AdviceMode.ASPECTJ<br>2. 任意参数类型都是支持的，但是方法返回值必须是void或者Future类型。当使用Future时，你可以使用 实现了Future接口的ListenableFuture接口或者CompletableFuture类与异步任务做更好的交互。如果异步方法有返回值，没有使用Future<V>类型的话，调用方获取不到返回值。</p><h2 id="配置">配置</h2><blockquote><p>spring.task.execution.pool.core-size=2<br>spring.task.execution.pool.max-size=5<br>spring.task.execution.pool.queue-capacity=10<br>spring.task.execution.pool.keep-alive=60s<br>spring.task.execution.pool.allow-core-thread-timeout=true<br>spring.task.execution.thread-name-prefix=task-</p></blockquote><blockquote><p><em><strong>含义：</strong></em><br><code>spring.task.execution.pool.core-size</code>：线程池创建时的初始化线程数，默认为8<br><code>spring.task.execution.pool.max-size</code>：线程池的最大线程数，默认为int最大值<br><code>spring.task.execution.pool.queue-capacity</code>：用来缓冲执行任务的队列，默认为int最大值<br><code>spring.task.execution.pool.keep-alive</code>：线程终止前允许保持空闲的时间<br><code>spring.task.execution.pool.allow-core-thread-timeout</code>：是否允许核心线程超时<br><code>spring.task.execution.shutdown.await-termination</code>：是否等待剩余任务完成后才关闭应用<br><code>spring.task.execution.shutdown.await-termination-period</code>：等待剩余任务完成的最大时间<br><code>spring.task.execution.thread-name-prefix</code>：线程名的前缀，设置好了之后可以方便我们在日志中查看处理任务所在的线程池</p></blockquote>]]></content>
    
    
    <summary type="html">关于Spring的@Async注解内容整理</summary>
    
    
    
    <category term="并发编程" scheme="https://www.zhen0w0.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC" scheme="https://www.zhen0w0.cn/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Redis实现分布式锁</title>
    <link href="https://www.zhen0w0.cn/posts/400a25e9.html"/>
    <id>https://www.zhen0w0.cn/posts/400a25e9.html</id>
    <published>2024-03-27T17:40:00.000Z</published>
    <updated>2024-03-27T17:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式锁">分布式锁</h2><blockquote><p><strong>控制分布式系统不同进程共同访问共享资源的一种锁实现的方式</strong>，如果不同的系统或者同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性</p></blockquote><p><em><strong>特征：</strong></em></p><ol><li><strong>互斥性</strong>：任意时刻，只有<strong>一个客户端</strong>能持有锁</li><li><strong>锁超时释放</strong>：持有锁超时，可以释放，防止不必要的资源浪费，也可以<strong>防止死锁</strong></li><li><strong>可重入性</strong>：可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。 说白了就是同一个线程再次进入同样代码时，可以再次拿到该锁。 （作用：防止在同一线程中多次获取锁导致死锁发生）</li><li><strong>高性能和高可用</strong>：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效（高性能：查询快，高可用：节点故障时，服务仍然能正常运行或进行降级后提供部分服务）</li><li><strong>安全性</strong>：锁只能被持有的用户删除，不能被其他客户端删除</li></ol><h2 id="实现方式（1）">实现方式（1）</h2><blockquote><p>SETNX + EXPIRE</p><p>SETNX KEY_NAME VALUE    //设置成功，返回 1 。 设置失败，返回 0 。</p><p>Expire KEY_NAME TIME_IN_SECONDS   //设置成功返回 1 。 当 key 不存在或者不能为 key 设置过期时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 key 的过期时间)返回 0</p><p>使用这个方案要注意 setnx 与 expire 之间的原子性操作，如果在执行完 setnx 之后服务器 crash 或重启了导致加的这个锁没有设置过期时间，就会导致死锁的情况（别的线程就永远获取不到锁了）</p></blockquote><h2 id="实现方式（2）">实现方式（2）</h2><blockquote><p>SETNX + value 值（系统时间 + 过期时间）</p></blockquote><p><em><strong>示例代码：</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统时间+设置的过期时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">expires</span> <span class="operator">=</span> System.currentTimeMillis() + expireTime; </span><br><span class="line"><span class="type">String</span> <span class="variable">expiresStr</span> <span class="operator">=</span> String.valueOf(expires);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前锁不存在，返回加锁成功</span></span><br><span class="line"><span class="keyword">if</span> (jedis.setnx(key_resource_id, expiresStr) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果锁已经存在，获取锁的过期时间</span></span><br><span class="line"><span class="type">String</span> <span class="variable">currentValueStr</span> <span class="operator">=</span> jedis.get(key_resource_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果获取到的过期时间，小于系统当前时间，表示已经过期</span></span><br><span class="line"><span class="keyword">if</span> (currentValueStr != <span class="literal">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间（不了解redis的getSet命令的小伙伴，可以去官网看下哈）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">oldValueStr</span> <span class="operator">=</span> jedis.getSet(key_resource_id, expiresStr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldValueStr != <span class="literal">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</span><br><span class="line">         <span class="comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//其他情况，均返回加锁失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>优点：</strong> 移除了 expire 单独设置过期时间的操作，把过期时间放到 setnx 的 value 值里面来，解决了所得不到释放的问题。<br><strong>缺点：</strong></p><ol><li>过期时间是客户端自己生成的（System.currentTimeMillis() 是当前系统的时间），必须要求分布式环境下，每个客户端的时间必须同步。</li><li>如果所过期的时候，并发多个客户端同时请求过来，都执行 jedis.getSet()，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，可能被其他的客户端覆盖。</li><li>该锁没有保存持有者的唯一标识，可能被别的客户端释放 / 解锁。</li></ol></blockquote><h2 id="实现方式（3）">实现方式（3）</h2><blockquote><p>使用 Lua 脚本（包含 SETNX + EXPIPE 两条指令）</p></blockquote><p><strong>lua脚本</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;setnx&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>]) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">   redis.call(<span class="string">&#x27;expire&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p><strong>加锁代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lua_scripts</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot;</span> +</span><br><span class="line">            <span class="string">&quot; redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span>;  </span><br><span class="line">             </span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(lua_scripts, Collections.singletonList(key_resource_id), Collections.singletonList(values));</span><br><span class="line"><span class="comment">//判断是否成功</span></span><br><span class="line"><span class="keyword">return</span> result.equals(<span class="number">1L</span>);</span><br></pre></td></tr></table></figure><h2 id="实现方式（4）">实现方式（4）</h2><blockquote><p>SET 的扩展命令（SET EX PX NX）</p><p>set key value EX seconds PX milliseconds NX|XX<br>EX seconds：设置失效时长，单位秒<br>PX milliseconds：设置失效时长，单位毫秒<br>NX：key不存在时设置value，成功返回OK，失败返回(nil)<br>XX：key存在时设置value，成功返回OK，失败返回(nil)</p></blockquote><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（jedis.set(key_resource_id, lock_value, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, 100s) == <span class="number">1</span>）&#123; <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something  <span class="comment">//业务处理</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">       jedis.del(key_resource_id); <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>隐患：</strong><br><strong>「锁过期释放了，业务还没执行完」</strong>。假设线程a获取锁成功，一直在执行临界区的代码。但是100s过去后，它还没执行完。但是，这时候锁已经过期了，此时线程b又请求过来。显然线程b就可以获得锁成功，也开始执行临界区的代码。那么问题就来了，临界区的业务代码都不是严格串行执行的啦。<br><strong>「锁被别的线程误删」</strong>。假设线程a执行完后，去释放锁。但是它不知道当前的锁可能是线程b持有的（线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁）。那线程a就把线程b的锁释放掉了，但是线程b临界区业务代码可能都还没执行完呢。</p></blockquote><h2 id="实现方式（5）">实现方式（5）</h2><blockquote><p>SET EX PX NX + 校验唯一随机值,再删除</p><p>给value值设置一个标记当前线程唯一的随机数，在删除的时候，进行校验</p></blockquote><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（jedis.set(key_resource_id, uni_request_id, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, 100s) == <span class="number">1</span>）&#123; <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something  <span class="comment">//业务处理</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//判断是不是当前线程加的锁,是才释放</span></span><br><span class="line">       <span class="keyword">if</span> (uni_request_id.equals(jedis.get(key_resource_id))) &#123;</span><br><span class="line">        jedis.del(lockKey); <span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>判断是不是当前线程加的锁</strong>和<strong>释放锁</strong>不是一个原子操作。如果调用jedis.del()释放锁的时候，可能这把锁已经不属于当前客户端，会解除他人加的锁。</p><p><code>判断成功后，锁释放前</code>锁超时，其他线程获取锁成功，此时将会释放其他线程的锁</p></blockquote><p><strong>lua脚本解决</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span> </span><br><span class="line">   <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>]) </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h2 id="实现方式（6）">实现方式（6）</h2><blockquote><p>Redisson框架</p></blockquote><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/githubblog/article/202403202404121454680.png" alt=""></p><blockquote><p>只要线程一加锁成功，就会启动一个<code>watch dog</code>看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用Redisson解决了<strong>锁过期释放，业务没执行完</strong>问题。</p></blockquote><h2 id="实现方式（7）">实现方式（7）</h2><blockquote><p>多机实现的分布式锁Redlock+Redisson</p></blockquote><p><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/githubblog/article/202403202404121457449.png" alt=""></p><blockquote><p>如果线程一在Redis的master节点上拿到了锁，但是加锁的key还没同步到slave节点。恰好这时，master节点发生故障，一个slave节点就会升级为master节点。线程二就可以获取同个key的锁啦，但线程一也已经拿到锁，锁的安全性就没了。</p></blockquote><blockquote><p>为了解决这个问题，Redis作者 antirez提出一种高级的分布式锁算法：Redlock。Redlock核心思想是这样的：<br>搞多个Redis master部署，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。</p></blockquote><blockquote><p>假设当前有5个Redis master节点，在5台服务器上面运行这些Redis实例<br><img src="https://zhen0w0.oss-cn-shanghai.aliyuncs.com/githubblog/article/202403202404121500016.png" alt=""></p></blockquote><blockquote><p><strong>RedLock的实现步骤如下：</strong><br>1. 获取当前时间，以毫秒为单位。<br>2. 按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间,我们就假设超时时间是50ms吧）。如果超时，跳过该master节点，尽快去尝试下一个master节点。<br>3. 客户端使用当前时间减去开始获取锁时间（即步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1，这里是5/2+1=3个节点）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，10s&gt; 30ms+40ms+50ms+4m0s+50ms）<br>4. 如果取到了锁，key的真正有效时间改变，需要减去获取锁所使用的时间。<br>5. 如果获取锁失败（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）<br><strong>简洁版</strong><br>1. 按顺序向5个master节点请求加锁<br>2. 根据设置的超时时间来判断，是不是要跳过该master节点<br>3. 如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功。<br>4. 如果获取锁失败，解锁</p></blockquote><h2 id="看门狗">看门狗</h2><h3 id="概述">概述</h3><blockquote><p>看门狗机制是Redission提供的一种自动延期机制，这个机制使得<strong>Redission提供的分布式锁是可以自动续期的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">lockWatchdogTimeout</span> <span class="operator">=</span> <span class="number">30</span> * <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p><strong>看门狗机制提供的默认超时时间是30*1000毫秒，也就是30秒</strong></p><p>如果一个线程获取锁后，运行程序到释放锁所花费的时间大于锁自动释放时间（也就是看门狗机制提供的超时时间30s），那么Redission会自动给<code>redis</code>中的目标锁延长超时时间。</p><p><strong>在Redission中想要启动看门狗机制，那么我们就不用获取锁的时候自己定义<code>leaseTime(锁自动释放时间)</code>。</strong></p><p>如果自己定义了锁自动释放时间的话，无论是通过<code>lock</code>还是<code>tryLock</code>方法，都无法启用看门狗机制。<br>但是，如果传入的<code>leaseTime</code>为-1，也是会开启看门狗机制的。</p></blockquote><hr><blockquote><p>分布式锁是不能设置永不过期的，这是为了避免在分布式的情况下，一个节点获取锁之后宕机从而出现死锁的情况，所以需要个分布式锁设置一个过期时间。但是这样会导致一个线程拿到锁后，在锁的过期时间到达的时候程序还没运行完，导致锁超时释放了，那么其他线程就能获取锁进来，从而出现问题。<br>所以，看门狗机制的自动续期，就很好地解决了这一个问题。</p></blockquote><hr><blockquote><p><strong>总结</strong><br>watch dog 在当前节点存活时每10s给分布式锁的key续期 30s；<br>watch dog 机制启动，且代码中没有释放锁操作时，watch dog 会不断的给锁续期；<br>如果程序释放锁操作时因为异常没有被执行，那么锁无法被释放，所以释放锁操作一定要放到 finally {} 中；<br>要使 watchLog机制生效 ，lock时 不要设置过期时间<br>watchlog的延时时间 可以由 lockWatchdogTimeout指定默认延时时间，但是不要设置太小。如100<br>watchdog 会每 lockWatchdogTimeout/3时间，去延时。<br>watchdog 通过 类似netty的 Future功能来实现异步延时<br>watchdog 最终还是通过 lua脚本来进行延时</p></blockquote><h2 id="使用案例">使用案例</h2><p><strong>原始代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;myLock&quot;</span>;  </span><br><span class="line"><span class="comment">//重新设置key对应的值，如果存在返回false，否则返回true</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(lockKey, <span class="string">&quot;zhen&quot;</span>);  <span class="comment">//加锁  </span></span><br><span class="line"><span class="keyword">if</span> (!result) &#123;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;error!&quot;</span>); <span class="comment">//抛出异常</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//执行业务  </span></span><br><span class="line">System.out.println(<span class="string">&quot;执行业务&quot;</span>);  </span><br><span class="line">stringRedisTemplate.delete(lockKey);  <span class="comment">//释放锁</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>问题：</strong><br>上述代码抛出异常执行，锁无法释放，出现死锁</p></blockquote><p><strong>改进一：try/finally语句</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;myLock&quot;</span>;  </span><br><span class="line">Boolean result;  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, <span class="string">&quot;zhen&quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;error!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//执行业务  </span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行业务&quot;</span>);  </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">    stringRedisTemplate.delete(lockKey);<span class="comment">//释放锁  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>问题</strong><br>finally 块执行前，程序部署机器死机，仍会出现上述问题</p></blockquote><p><strong>改进二：设置过期时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;myLock&quot;</span>;  </span><br><span class="line">Boolean result;  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, <span class="string">&quot;zhen&quot;</span>);<span class="comment">//加锁  </span></span><br><span class="line">    stringRedisTemplate.expire(lockKey, <span class="number">30</span>, TimeUnit.SECONDS);<span class="comment">//设置有效期  </span></span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;error!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//执行业务  </span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行业务&quot;</span>);  </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">    stringRedisTemplate.delete(lockKey);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>问题：</strong><br>设置过期时间语句未执行，程序部署机器死机，发生死锁<br><strong>改进：</strong><br>同时设置value&amp;时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, <span class="string">&quot;zhen&quot;</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>问题：</strong><br>高并发情况下，<code>线程1</code>获取锁，锁有效期10s，业务代码执行15s，<code>线程2</code>同样获取该锁，有效期10s，业务代码执行15s<br>当前情况意味着，<code>线程1</code>业务完成后，锁已经被<code>线程2</code>持有，因此<code>线程1</code>的锁释放操作，释放的是<code>线程2</code>的锁，并且<code>线程2</code>尚未执行完成</p></blockquote><p><strong>改进三：value随机值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;myLock&quot;</span>;  </span><br><span class="line">Boolean result;  </span><br><span class="line"><span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> UUID.randomUUID().toString();<span class="comment">//生成随机值  </span></span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, requestId, <span class="number">10</span>, TimeUnit.SECONDS);  </span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;error!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//执行业务  </span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行业务&quot;</span>);  </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (requestId.equals(stringRedisTemplate.opsForValue().get(lockKey))) &#123;  </span><br><span class="line">        stringRedisTemplate.delete(lockKey);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>问题：</strong><br>功能完备，但是时间设置无法判断，如果锁失效时间设置为5s，可能太少<code>锁不住</code>，但如果设置为30s，也可能不够，<code>无法确定业务执行时间</code><br>时间太长，会导致其他线程获取锁的等待时间拉长，影响程序运行效率<br><strong>改进：</strong><br>新建一个分支线程，设置一个定时任务，比如每10s判断一下线程还活着没，如果这个线程存在，就把expire再设置成30s，重置锁的失效时间</p></blockquote><p><strong>改进四：直接采用redisson</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;myLock&quot;</span>;  </span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(lockKey);<span class="comment">//1 获得锁对象  </span></span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    lock.lock();<span class="comment">//2  加锁（默认设置了有效时间，并开启分支线程定时续命）  </span></span><br><span class="line">    <span class="comment">//业务  </span></span><br><span class="line">    System.out.println(<span class="string">&quot;业务&quot;</span>);  </span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;  </span><br><span class="line">    lock.unlock();<span class="comment">//3  解锁  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解实现分布式锁">注解实现分布式锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RedisLock &#123;</span><br><span class="line">    <span class="comment">//锁的名称</span></span><br><span class="line">    String <span class="title function_">lockName</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//锁的失效时间</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">leaseTime</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//是否开启看门狗，默认开启，开启时锁的失效时间不执行。任务未完成时会自动续期锁时间</span></span><br><span class="line">    <span class="comment">//使用看门狗，锁默认redis失效时间未30秒。失效时间剩余1/3时进行续期判断，是否需要续期</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">watchdog</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLockAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;redisson_lock:&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(redisLock)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint, RedisLock redisLock)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockName</span> <span class="operator">=</span> redisLock.lockName();</span><br><span class="line"> </span><br><span class="line">        <span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> redissonClient.getLock(REDIS_PREFIX + lockName);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> isLock;</span><br><span class="line">        <span class="keyword">if</span>(redisLock.watchdog())&#123;</span><br><span class="line">            isLock =rLock.tryLock(<span class="number">0</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            isLock =rLock.tryLock(<span class="number">0</span>,redisLock.leaseTime(), TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行方法</span></span><br><span class="line">                result = joinPoint.proceed();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rLock.isLocked() &amp;&amp; rLock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                    rLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;The lock has been taken:&#123;&#125;&quot;</span>,REDIS_PREFIX + lockName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用注解进行加锁</span></span><br><span class="line">    <span class="meta">@RedisLock(lockName = &quot;npa_lock_test&quot;,watchdog = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">redisLockTest</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;get lock and perform a task&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于Redis实现分布式锁的一些内容的梳理与整合</summary>
    
    
    
    <category term="数据库" scheme="https://www.zhen0w0.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="redis" scheme="https://www.zhen0w0.cn/tags/redis/"/>
    
    <category term="分布式" scheme="https://www.zhen0w0.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
